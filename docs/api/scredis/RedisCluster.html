<!DOCTYPE html ><html><head><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport"/><title></title><meta content="" name="description"/><meta content="" name="keywords"/><meta http-equiv="content-type" content="text/html; charset=UTF-8"/><link href="../lib/index.css" media="screen" type="text/css" rel="stylesheet"/><link href="../lib/template.css" media="screen" type="text/css" rel="stylesheet"/><link href="../lib/print.css" media="print" type="text/css" rel="stylesheet"/><link href="../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css"/><script type="text/javascript" src="../lib/jquery.min.js"></script><script type="text/javascript" src="../lib/index.js"></script><script type="text/javascript" src="../index.js"></script><script type="text/javascript" src="../lib/scheduler.js"></script><script type="text/javascript" src="../lib/template.js"></script><script type="text/javascript">/* this variable can be used by the JS to determine the path to the root document */
var toRoot = '../';</script></head><body><div id="search"><span id="doc-title"><span id="doc-version"></span></span> <span class="close-results"><span class="left">&lt;</span> Back</span><div id="textfilter"><span class="input"><input autocapitalize="none" placeholder="Search" id="index-input" type="text" accesskey="/"/><i class="clear material-icons"></i><i id="search-icon" class="material-icons"></i></span></div></div><div id="search-results"><div id="search-progress"><div id="progress-fill"></div></div><div id="results-content"><div id="entity-results"></div><div id="member-results"></div></div></div><div id="content-scroll-container" style="-webkit-overflow-scrolling: touch;"><div id="content-container" style="-webkit-overflow-scrolling: touch;"><div id="subpackage-spacer"><div id="packages"><h1>Packages</h1><ul><li class="indented0 " name="_root_.root" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="_root_"></a><a id="root:_root_"></a> <span class="permalink"><a href="../index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../index.html" title=""><span class="name">root</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="_root_" id="_root_" class="extype">root</a></dd></dl></div></li><li class="indented1 " name="_root_.scredis" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="scredis"></a><a id="scredis:scredis"></a> <span class="permalink"><a href="../scredis/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="index.html" title=""><span class="name">scredis</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="_root_" id="_root_" class="extype">root</a></dd></dl></div></li><li class="indented2 " name="scredis.commands" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="commands"></a><a id="commands:commands"></a> <span class="permalink"><a href="../scredis/commands/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="commands/index.html" title=""><span class="name">commands</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="index.html" name="scredis" id="scredis" class="extype">scredis</a></dd></dl></div></li><li class="indented2 " name="scredis.exceptions" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="exceptions"></a><a id="exceptions:exceptions"></a> <span class="permalink"><a href="../scredis/exceptions/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="exceptions/index.html" title=""><span class="name">exceptions</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="index.html" name="scredis" id="scredis" class="extype">scredis</a></dd></dl></div></li><li class="indented2 " name="scredis.io" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="io"></a><a id="io:io"></a> <span class="permalink"><a href="../scredis/io/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="io/index.html" title=""><span class="name">io</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="index.html" name="scredis" id="scredis" class="extype">scredis</a></dd></dl></div></li><li class="indented2 " name="scredis.protocol" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="protocol"></a><a id="protocol:protocol"></a> <span class="permalink"><a href="../scredis/protocol/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="protocol/index.html" title=""><span class="name">protocol</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="index.html" name="scredis" id="scredis" class="extype">scredis</a></dd></dl></div></li><li class="indented2 " name="scredis.serialization" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="serialization"></a><a id="serialization:serialization"></a> <span class="permalink"><a href="../scredis/serialization/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="serialization/index.html" title=""><span class="name">serialization</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="index.html" name="scredis" id="scredis" class="extype">scredis</a></dd></dl></div></li><li class="indented2 " name="scredis.util" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="util"></a><a id="util:util"></a> <span class="permalink"><a href="../scredis/util/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="util/index.html" title=""><span class="name">util</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="index.html" name="scredis" id="scredis" class="extype">scredis</a></dd></dl></div></li><li class="current-entities indented1"><a href="package$$Aggregate$.html" title="Contains all available aggregation functions" class="object"></a> <a href="package$$Aggregate.html" title="Represents the aggregation function to be used for aggregating scores when computing the union or intersection of sorted sets" class="class"></a><a href="package$$Aggregate.html" title="Represents the aggregation function to be used for aggregating scores when computing the union or intersection of sorted sets">Aggregate</a></li><li class="current-entities indented1"><a href="package$$BitOp$.html" title="Contains all available BITOP operations, i.e." class="object"></a> <a href="package$$BitOp.html" title="Base class of a BITOP operation" class="class"></a><a href="package$$BitOp.html" title="Base class of a BITOP operation">BitOp</a></li><li class="current-entities indented1"><a href="BlockingClient$.html" title="The companion object provides additional friendly constructors." class="object"></a> <a href="BlockingClient.html" title="Defines a Redis client supporting all blocking commands." class="class"></a><a href="BlockingClient.html" title="Defines a Redis client supporting all blocking commands.">BlockingClient</a></li><li class="current-entities indented1"><span class="separator"></span> <a href="BuildInfo$.html" title="This object was generated by sbt-buildinfo." class="object"></a><a href="BuildInfo$.html" title="This object was generated by sbt-buildinfo.">BuildInfo</a></li><li class="current-entities indented1"><a href="Client$.html" title="The companion object provides additional friendly constructors." class="object"></a> <a href="Client.html" title="Defines a Redis client supporting all non-blocking commands." class="class"></a><a href="Client.html" title="Defines a Redis client supporting all non-blocking commands.">Client</a></li><li class="current-entities indented1"><a href="package$$ClientType$.html" title="Contains all available client types, i.e." class="object"></a> <a href="package$$ClientType.html" title="Represents the type of a connected client" class="class"></a><a href="package$$ClientType.html" title="Represents the type of a connected client">ClientType</a></li><li class="current-entities indented1"><span class="separator"></span> <a href="package$$ClusterNode.html" title="Information returned by CLUSTER NODES and CLUSTER SLAVES command." class="class"></a><a href="package$$ClusterNode.html" title="Information returned by CLUSTER NODES and CLUSTER SLAVES command.">ClusterNode</a></li><li class="current-entities indented1"><span class="separator"></span> <a href="package$$ClusterSlotRange.html" title="Information about slot ranges returned by the CLUSTER SLOTS command." class="class"></a><a href="package$$ClusterSlotRange.html" title="Information about slot ranges returned by the CLUSTER SLOTS command.">ClusterSlotRange</a></li><li class="current-entities indented1"><span class="separator"></span> <a href="package$$ClusterSlotRangeNodeInfo.html" title="Information about cluster node in slot range." class="class"></a><a href="package$$ClusterSlotRangeNodeInfo.html" title="Information about cluster node in slot range.">ClusterSlotRangeNodeInfo</a></li><li class="current-entities indented1"><span class="separator"></span> <a href="package$$CommandFlags.html" title="Helper class containing the flags of a command" class="class"></a><a href="package$$CommandFlags.html" title="Helper class containing the flags of a command">CommandFlags</a></li><li class="current-entities indented1"><span class="separator"></span> <a href="package$$CommandInfo.html" title="Holds information about a Redis command." class="class"></a><a href="package$$CommandInfo.html" title="Holds information about a Redis command.">CommandInfo</a></li><li class="current-entities indented1"><a href="package$$Condition$.html" title="Contains all available conditions" class="object"></a> <a href="package$$Condition.html" title="Represents a condition that can be passed to some Redis command, e.g." class="class"></a><a href="package$$Condition.html" title="Represents a condition that can be passed to some Redis command, e.g.">Condition</a></li><li class="current-entities indented1"><a href="package$$LexicalScoreLimit$.html" title="Contains all possible lexical score limits, i.e." class="object"></a> <a href="package$$LexicalScoreLimit.html" title="Represents one end of a lexical interval as defined by sorted set commands" class="class"></a><a href="package$$LexicalScoreLimit.html" title="Represents one end of a lexical interval as defined by sorted set commands">LexicalScoreLimit</a></li><li class="current-entities indented1"><a href="package$$Position$.html" title="Contains all available positions, i.e." class="object"></a> <a href="package$$Position.html" title="Base class of a position used for the LINSERT command" class="class"></a><a href="package$$Position.html" title="Base class of a position used for the LINSERT command">Position</a></li><li class="current-entities indented1"><a href="package$$PubSubMessage$.html" title="Contains all pub/sub messages." class="object"></a> <a href="package$$PubSubMessage.html" title="Base trait for all pub/sub messages." class="trait"></a><a href="package$$PubSubMessage.html" title="Base trait for all pub/sub messages.">PubSubMessage</a></li><li class="current-entities indented1"><a href="Redis$.html" title="The companion object provides additional friendly constructors." class="object"></a> <a href="Redis.html" title="Defines a Redis scredis.Client supporting all non-blocking commands along with a lazily initialized scredis.BlockingClient and scredis.SubscriberClient." class="class"></a><a href="Redis.html" title="Defines a Redis scredis.Client supporting all non-blocking commands along with a lazily initialized scredis.BlockingClient and scredis.SubscriberClient.">Redis</a></li><li class="current-entities indented1"><a href="RedisCluster$.html" title="" class="object"></a> <a href="" title="Defines a RedisCluster scredis.Client supporting all non-blocking commands that can be addressed to either any cluster node or be automatically routed to the correct node." class="class"></a><a href="" title="Defines a RedisCluster scredis.Client supporting all non-blocking commands that can be addressed to either any cluster node or be automatically routed to the correct node.">RedisCluster</a></li><li class="current-entities indented1"><a href="RedisConfig$.html" title="" class="object"></a> <a href="RedisConfig.html" title="Holds all configurable parameters." class="class"></a><a href="RedisConfig.html" title="Holds all configurable parameters.">RedisConfig</a></li><li class="current-entities indented1"><span class="separator"></span> <a href="RedisConfigDefaults$.html" title="" class="object"></a><a href="RedisConfigDefaults$.html" title="">RedisConfigDefaults</a></li><li class="current-entities indented1"><a href="package$$Role$.html" title="Contains all available roles, i.e." class="object"></a> <a href="package$$Role.html" title="Represents the role of a Redis instance as returned by the ROLE command" class="class"></a><a href="package$$Role.html" title="Represents the role of a Redis instance as returned by the ROLE command">Role</a></li><li class="current-entities indented1"><a href="package$$Score$.html" title="Contains all possible score values, i.e." class="object"></a> <a href="package$$Score.html" title="Represents the score of sorted set member" class="class"></a><a href="package$$Score.html" title="Represents the score of sorted set member">Score</a></li><li class="current-entities indented1"><a href="package$$ScoreLimit$.html" title="Contains all possible score limit values, i.e." class="object"></a> <a href="package$$ScoreLimit.html" title="Represents one end of an interval as defined by sorted set commands" class="class"></a><a href="package$$ScoreLimit.html" title="Represents one end of an interval as defined by sorted set commands">ScoreLimit</a></li><li class="current-entities indented1"><span class="separator"></span> <a href="package$$Server.html" title="Connection information for a server node in a Redis cluster" class="class"></a><a href="package$$Server.html" title="Connection information for a server node in a Redis cluster">Server</a></li><li class="current-entities indented1"><a href="package$$ShutdownModifier$.html" title="Contains all available SHUTDOWN modifier, i.e." class="object"></a> <a href="package$$ShutdownModifier.html" title="Represents a modifier that can be used with the SHUTDOWN command" class="class"></a><a href="package$$ShutdownModifier.html" title="Represents a modifier that can be used with the SHUTDOWN command">ShutdownModifier</a></li><li class="current-entities indented1"><span class="separator"></span> <a href="package$$SlowLogEntry.html" title="Represents an entry returned by the SLOWLOG GET command" class="class"></a><a href="package$$SlowLogEntry.html" title="Represents an entry returned by the SLOWLOG GET command">SlowLogEntry</a></li><li class="current-entities indented1"><a href="SubscriberClient$.html" title="The companion object provides additional friendly constructors." class="object"></a> <a href="SubscriberClient.html" title="Defines a Pub/Sub Redis client capable of subscribing to channels/patterns." class="class"></a><a href="SubscriberClient.html" title="Defines a Pub/Sub Redis client capable of subscribing to channels/patterns.">SubscriberClient</a></li><li class="current-entities indented1"><span class="separator"></span> <a href="TransactionBuilder.html" title="" class="class"></a><a href="TransactionBuilder.html" title="">TransactionBuilder</a></li><li class="current-entities indented1"><a href="package$$Type$.html" title="Contains all available Redis types, i.e." class="object"></a> <a href="package$$Type.html" title="Represents the type of a Redis key" class="class"></a><a href="package$$Type.html" title="Represents the type of a Redis key">Type</a></li></ul></div></div><div id="content"><body class="class type"><div id="definition"><a href="RedisCluster$.html" title="See companion object"><div class="big-circle class-companion-object">c</div></a><p id="owner"><a href="index.html" name="scredis" id="scredis" class="extype">scredis</a></p><h1><a href="RedisCluster$.html" title="See companion object">RedisCluster</a><span class="permalink"><a href="../scredis/RedisCluster.html" title="Permalink"><i class="material-icons"></i></a></span></h1><h3><span class="morelinks"><div>Companion <a href="RedisCluster$.html" title="See companion object">object RedisCluster</a></div></span></h3></div><h4 id="signature" class="signature"><span class="modifier_kind"><span class="modifier"></span> <span class="kind">class</span></span> <span class="symbol"><span class="name">RedisCluster</span><span class="result"> extends <a href="io/ClusterConnection.html" name="scredis.io.ClusterConnection" id="scredis.io.ClusterConnection" class="extype">ClusterConnection</a> with <a href="io/Connection.html" name="scredis.io.Connection" id="scredis.io.Connection" class="extype">Connection</a> with <a href="commands/ClusterCommands.html" name="scredis.commands.ClusterCommands" id="scredis.commands.ClusterCommands" class="extype">ClusterCommands</a> with <a href="commands/HashCommands.html" name="scredis.commands.HashCommands" id="scredis.commands.HashCommands" class="extype">HashCommands</a> with <a href="commands/HyperLogLogCommands.html" name="scredis.commands.HyperLogLogCommands" id="scredis.commands.HyperLogLogCommands" class="extype">HyperLogLogCommands</a> with <a href="commands/KeyCommands.html" name="scredis.commands.KeyCommands" id="scredis.commands.KeyCommands" class="extype">KeyCommands</a> with <a href="commands/ListCommands.html" name="scredis.commands.ListCommands" id="scredis.commands.ListCommands" class="extype">ListCommands</a> with <a href="commands/PubSubCommands.html" name="scredis.commands.PubSubCommands" id="scredis.commands.PubSubCommands" class="extype">PubSubCommands</a> with <a href="commands/ScriptingCommands.html" name="scredis.commands.ScriptingCommands" id="scredis.commands.ScriptingCommands" class="extype">ScriptingCommands</a> with <a href="commands/SetCommands.html" name="scredis.commands.SetCommands" id="scredis.commands.SetCommands" class="extype">SetCommands</a> with <a href="commands/SortedSetCommands.html" name="scredis.commands.SortedSetCommands" id="scredis.commands.SortedSetCommands" class="extype">SortedSetCommands</a> with <a href="commands/StringCommands.html" name="scredis.commands.StringCommands" id="scredis.commands.StringCommands" class="extype">StringCommands</a></span></span></h4><div id="comment" class="fullcommenttop"><div class="comment cmt"><p>Defines a <code>RedisCluster</code> <a href="Client.html" name="scredis.Client" id="scredis.Client" class="extype">scredis.Client</a> supporting all non-blocking commands that can be addressed to either
any cluster node or be automatically routed to the correct node.</p></div><div class="toggleContainer"><div class="toggle block"><span>Linear Supertypes</span><div class="superTypes hiddenContent"><a href="commands/StringCommands.html" name="scredis.commands.StringCommands" id="scredis.commands.StringCommands" class="extype">StringCommands</a>, <a href="commands/SortedSetCommands.html" name="scredis.commands.SortedSetCommands" id="scredis.commands.SortedSetCommands" class="extype">SortedSetCommands</a>, <a href="commands/SetCommands.html" name="scredis.commands.SetCommands" id="scredis.commands.SetCommands" class="extype">SetCommands</a>, <a href="commands/ScriptingCommands.html" name="scredis.commands.ScriptingCommands" id="scredis.commands.ScriptingCommands" class="extype">ScriptingCommands</a>, <a href="commands/PubSubCommands.html" name="scredis.commands.PubSubCommands" id="scredis.commands.PubSubCommands" class="extype">PubSubCommands</a>, <a href="commands/ListCommands.html" name="scredis.commands.ListCommands" id="scredis.commands.ListCommands" class="extype">ListCommands</a>, <a href="commands/KeyCommands.html" name="scredis.commands.KeyCommands" id="scredis.commands.KeyCommands" class="extype">KeyCommands</a>, <a href="commands/HyperLogLogCommands.html" name="scredis.commands.HyperLogLogCommands" id="scredis.commands.HyperLogLogCommands" class="extype">HyperLogLogCommands</a>, <a href="commands/HashCommands.html" name="scredis.commands.HashCommands" id="scredis.commands.HashCommands" class="extype">HashCommands</a>, <a href="commands/ClusterCommands.html" name="scredis.commands.ClusterCommands" id="scredis.commands.ClusterCommands" class="extype">ClusterCommands</a>, <a href="io/Connection.html" name="scredis.io.Connection" id="scredis.io.Connection" class="extype">Connection</a>, <a href="io/ClusterConnection.html" name="scredis.io.ClusterConnection" id="scredis.io.ClusterConnection" class="extype">ClusterConnection</a>, <span name="com.typesafe.scalalogging.LazyLogging" class="extype">LazyLogging</span>, <a href="io/NonBlockingConnection.html" name="scredis.io.NonBlockingConnection" id="scredis.io.NonBlockingConnection" class="extype">NonBlockingConnection</a>, <a href="https://www.scala-lang.org/api/2.13.1/scala/AnyRef.html#scala.AnyRef" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a>, <a href="https://www.scala-lang.org/api/2.13.1/scala/Any.html#scala.Any" name="scala.Any" id="scala.Any" class="extype">Any</a></div></div></div></div><div id="mbrsel"><div class="toggle"></div><div id="memberfilter"><i class="material-icons arrow"></i><span class="input"><input placeholder="Filter all members" id="mbrsel-input" type="text" accesskey="/"/></span><i class="clear material-icons"></i></div><div id="filterby"><div id="order"><span class="filtertype">Ordering</span><ol><li class="alpha in"><span>Alphabetic</span></li><li class="inherit out"><span>By Inheritance</span></li></ol></div><div class="ancestors"><span class="filtertype">Inherited<br/></span><ol id="linearization"><li class="in" name="scredis.RedisCluster"><span>RedisCluster</span></li><li class="in" name="scredis.commands.StringCommands"><span>StringCommands</span></li><li class="in" name="scredis.commands.SortedSetCommands"><span>SortedSetCommands</span></li><li class="in" name="scredis.commands.SetCommands"><span>SetCommands</span></li><li class="in" name="scredis.commands.ScriptingCommands"><span>ScriptingCommands</span></li><li class="in" name="scredis.commands.PubSubCommands"><span>PubSubCommands</span></li><li class="in" name="scredis.commands.ListCommands"><span>ListCommands</span></li><li class="in" name="scredis.commands.KeyCommands"><span>KeyCommands</span></li><li class="in" name="scredis.commands.HyperLogLogCommands"><span>HyperLogLogCommands</span></li><li class="in" name="scredis.commands.HashCommands"><span>HashCommands</span></li><li class="in" name="scredis.commands.ClusterCommands"><span>ClusterCommands</span></li><li class="in" name="scredis.io.Connection"><span>Connection</span></li><li class="in" name="scredis.io.ClusterConnection"><span>ClusterConnection</span></li><li class="in" name="com.typesafe.scalalogging.LazyLogging"><span>LazyLogging</span></li><li class="in" name="scredis.io.NonBlockingConnection"><span>NonBlockingConnection</span></li><li class="in" name="scala.AnyRef"><span>AnyRef</span></li><li class="in" name="scala.Any"><span>Any</span></li></ol></div><div class="ancestors"><span class="filtertype"></span><ol><li class="hideall out"><span>Hide All</span></li><li class="showall in"><span>Show All</span></li></ol></div><div id="visbl"><span class="filtertype">Visibility</span><ol><li class="public in"><span>Public</span></li><li class="protected out"><span>Protected</span></li></ol></div></div></div><div id="template"><div id="allMembers"><div id="constructors" class="members"><h3>Instance Constructors</h3><ol><li class="indented0 " name="scredis.RedisCluster#&lt;init&gt;" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="&lt;init&gt;(system:akka.actor.ActorSystem):scredis.RedisCluster"></a><a id="&lt;init&gt;:RedisCluster"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#&lt;init&gt;(system:akka.actor.ActorSystem):scredis.RedisCluster" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">new</span></span> <span class="symbol"><span class="name">RedisCluster</span><span class="params">(<span name="system">system: <a href="https://doc.akka.io/api/akka/2.5.26/akka/actor/ActorSystem.html#akka.actor.ActorSystem" name="akka.actor.ActorSystem" id="akka.actor.ActorSystem" class="extype">ActorSystem</a></span>)</span></span><p class="shortcomment cmt">Constructs a <a href="" name="scredis.RedisCluster" id="scredis.RedisCluster" class="extype">scredis.RedisCluster</a> instance using the default config.</p><div class="fullcomment"><div class="comment cmt"><p>Constructs a <a href="" name="scredis.RedisCluster" id="scredis.RedisCluster" class="extype">scredis.RedisCluster</a> instance using the default config.
</p></div><dl class="paramcmts block"><dt class="param">system</dt><dd class="cmt"><p>Actor system</p></dd><dt>returns</dt><dd class="cmt"><p>the constructed <a href="" name="scredis.RedisCluster" id="scredis.RedisCluster" class="extype">scredis.RedisCluster</a></p></dd></dl></div></li><li class="indented0 " name="scredis.RedisCluster#&lt;init&gt;" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="&lt;init&gt;():scredis.RedisCluster"></a><a id="&lt;init&gt;:RedisCluster"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#&lt;init&gt;():scredis.RedisCluster" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">new</span></span> <span class="symbol"><span class="name">RedisCluster</span><span class="params">()</span></span><p class="shortcomment cmt">Constructs a <a href="" name="scredis.RedisCluster" id="scredis.RedisCluster" class="extype">scredis.RedisCluster</a> instance using the default config.</p><div class="fullcomment"><div class="comment cmt"><p>Constructs a <a href="" name="scredis.RedisCluster" id="scredis.RedisCluster" class="extype">scredis.RedisCluster</a> instance using the default config.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>the constructed <a href="" name="scredis.RedisCluster" id="scredis.RedisCluster" class="extype">scredis.RedisCluster</a></p></dd></dl></div></li><li class="indented0 " name="scredis.RedisCluster#&lt;init&gt;" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="&lt;init&gt;(config:scredis.RedisConfig,systemOpt:Option[akka.actor.ActorSystem]):scredis.RedisCluster"></a><a id="&lt;init&gt;:RedisCluster"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#&lt;init&gt;(config:scredis.RedisConfig,systemOpt:Option[akka.actor.ActorSystem]):scredis.RedisCluster" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">new</span></span> <span class="symbol"><span class="name">RedisCluster</span><span class="params">(<span name="config">config: <a href="RedisConfig.html" name="scredis.RedisConfig" id="scredis.RedisConfig" class="extype">RedisConfig</a></span>, <span name="systemOpt">systemOpt: <a href="https://www.scala-lang.org/api/2.13.1/scala/Option.html#scala.Option" name="scala.Option" id="scala.Option" class="extype">Option</a>[<a href="https://doc.akka.io/api/akka/2.5.26/akka/actor/ActorSystem.html#akka.actor.ActorSystem" name="akka.actor.ActorSystem" id="akka.actor.ActorSystem" class="extype">ActorSystem</a>]</span>)</span></span><p class="shortcomment cmt">Constructs a <a href="" name="scredis.RedisCluster" id="scredis.RedisCluster" class="extype">scredis.RedisCluster</a> instance from a <a href="RedisConfig.html" name="scredis.RedisConfig" id="scredis.RedisConfig" class="extype">scredis.RedisConfig</a>.</p><div class="fullcomment"><div class="comment cmt"><p>Constructs a <a href="" name="scredis.RedisCluster" id="scredis.RedisCluster" class="extype">scredis.RedisCluster</a> instance from a <a href="RedisConfig.html" name="scredis.RedisConfig" id="scredis.RedisConfig" class="extype">scredis.RedisConfig</a>.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>the constructed <a href="" name="scredis.RedisCluster" id="scredis.RedisCluster" class="extype">scredis.RedisCluster</a></p></dd></dl></div></li></ol></div><div class="values members"><h3>Value Members</h3><ol><li class="indented0 " name="scala.AnyRef#!=" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="!=(x$1:Any):Boolean"></a><a id="!=(Any):Boolean"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#!=(x$1:Any):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $bang$eq">!=</span><span class="params">(<span name="arg0">arg0: <a href="https://www.scala-lang.org/api/2.13.1/scala/Any.html#scala.Any" name="scala.Any" id="scala.Any" class="extype">Any</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="scala.AnyRef###" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="##():Int"></a> <span class="permalink"><a href="../scredis/RedisCluster.html###():Int" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $hash$hash">##</span><span class="params">()</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="scala.AnyRef#==" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="==(x$1:Any):Boolean"></a><a id="==(Any):Boolean"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#==(x$1:Any):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $eq$eq">==</span><span class="params">(<span name="arg0">arg0: <a href="https://www.scala-lang.org/api/2.13.1/scala/Any.html#scala.Any" name="scala.Any" id="scala.Any" class="extype">Any</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="scredis.commands.StringCommands#append" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="append[W](key:String,value:W)(implicitevidence$1:scredis.serialization.Writer[W]):scala.concurrent.Future[Long]"></a><a id="append[W](String,W)(Writer[W]):Future[Long]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#append[W](key:String,value:W)(implicitevidence$1:scredis.serialization.Writer[W]):scala.concurrent.Future[Long]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">append</span><span class="tparams">[<span name="W">W</span>]</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="value">value: <span name="scredis.commands.StringCommands.append.W" class="extype">W</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Writer.html" name="scredis.serialization.Writer" id="scredis.serialization.Writer" class="extype">Writer</a>[<span name="scredis.commands.StringCommands.append.W" class="extype">W</span>]</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a>]</span></span><p class="shortcomment cmt">Appends a value to a key.</p><div class="fullcomment"><div class="comment cmt"><p>Appends a value to a key.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>the key to be appended</p></dd><dt class="param">value</dt><dd class="cmt"><p>the value to append</p></dd><dt>returns</dt><dd class="cmt"><p>the length of the string after the append operation</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/StringCommands.html" name="scredis.commands.StringCommands" id="scredis.commands.StringCommands" class="extype">StringCommands</a></dd><dt>Since</dt><dd><p>2.0.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if the value stored at key is not of type string</p></span></dd></dl></div></li><li class="indented0 " name="scala.Any#asInstanceOf" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="asInstanceOf[T0]:T0"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#asInstanceOf[T0]:T0" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">asInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span name="scala.Any.asInstanceOf.T0" class="extype">T0</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>Any</dd></dl></div></li><li class="indented0 " name="scredis.commands.StringCommands#bitCount" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="bitCount(key:String,start:Long,stop:Long):scala.concurrent.Future[Long]"></a><a id="bitCount(String,Long,Long):Future[Long]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#bitCount(key:String,start:Long,stop:Long):scala.concurrent.Future[Long]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">bitCount</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="start">start: <a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a> = <span class="symbol">0</span></span>, <span name="stop">stop: <a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a> = <span class="symbol">-1</span></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a>]</span></span><p class="shortcomment cmt">Counts the number of bits set to 1 in a string from start offset to stop offset.</p><div class="fullcomment"><div class="comment cmt"><p>Counts the number of bits set to 1 in a string from start offset to stop offset.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>the key for which the bitcount should be returned</p></dd><dt class="param">start</dt><dd class="cmt"><p>start offset (defaults to 0)</p></dd><dt class="param">stop</dt><dd class="cmt"><p>stop offset (defaults to -1)</p></dd><dt>returns</dt><dd class="cmt"><p>the number of bits set to 1 in the specified interval</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/StringCommands.html" name="scredis.commands.StringCommands" id="scredis.commands.StringCommands" class="extype">StringCommands</a></dd><dt>Since</dt><dd><p>2.6.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if the value stored at key is not of type string</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>Non-existent keys are treated as empty strings, so the command will return zero.</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.StringCommands#bitOp" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="bitOp(operation:scredis.BitOp,destKey:String,keys:String*):scala.concurrent.Future[Long]"></a><a id="bitOp(BitOp,String,String*):Future[Long]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#bitOp(operation:scredis.BitOp,destKey:String,keys:String*):scala.concurrent.Future[Long]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">bitOp</span><span class="params">(<span name="operation">operation: <a href="package$$BitOp.html" name="scredis.BitOp" id="scredis.BitOp" class="extype">BitOp</a></span>, <span name="destKey">destKey: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="keys">keys: <span name="scala.Predef.String" class="extype">String</span>*</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a>]</span></span><p class="shortcomment cmt">Performs a bitwise operation between multiple strings.</p><div class="fullcomment"><div class="comment cmt"><p>Performs a bitwise operation between multiple strings.
</p></div><dl class="paramcmts block"><dt class="param">operation</dt><dd class="cmt"><p><a href="package$$BitOp.html" name="scredis.BitOp" id="scredis.BitOp" class="extype">scredis.BitOp</a> to perform</p></dd><dt class="param">destKey</dt><dd class="cmt"><p>destination key where the result of the operation will be stored</p></dd><dt class="param">keys</dt><dd class="cmt"><p>keys to perform the operation upon</p></dd><dt>returns</dt><dd class="cmt"><p>the size of the string stored in the destination key, that is equal to the size of
the longest input string</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/StringCommands.html" name="scredis.commands.StringCommands" id="scredis.commands.StringCommands" class="extype">StringCommands</a></dd><dt>Since</dt><dd><p>2.6.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if at least one of the values stored at keys is not of type string</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>When an operation is performed between strings having different lengths, all the strings
shorter than the longest string in the set are treated as if they were zero-padded up to the
length of the longest string. The same holds true for non-existent keys, that are considered
as a stream of zero bytes up to the length of the longest string.</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.StringCommands#bitPos" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="bitPos(key:String,bit:Boolean,start:Long,stop:Long):scala.concurrent.Future[Long]"></a><a id="bitPos(String,Boolean,Long,Long):Future[Long]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#bitPos(key:String,bit:Boolean,start:Long,stop:Long):scala.concurrent.Future[Long]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">bitPos</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="bit">bit: <a href="https://www.scala-lang.org/api/2.13.1/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span>, <span name="start">start: <a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a> = <span class="symbol">0</span></span>, <span name="stop">stop: <a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a> = <span class="symbol">-1</span></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a>]</span></span><p class="shortcomment cmt">Return the position of the first bit set to 1 or 0 in a string.</p><div class="fullcomment"><div class="comment cmt"><p>Return the position of the first bit set to 1 or 0 in a string.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>string key</p></dd><dt class="param">bit</dt><dd class="cmt"><p>provide <b>true</b> to look for 1s and <b>false</b> to look for 0s</p></dd><dt class="param">start</dt><dd class="cmt"><p>start offset, in bytes</p></dd><dt class="param">stop</dt><dd class="cmt"><p>stop offset, in bytes</p></dd><dt>returns</dt><dd class="cmt"><p>the position of the first bit set to 1 or 0, according to the request</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/StringCommands.html" name="scredis.commands.StringCommands" id="scredis.commands.StringCommands" class="extype">StringCommands</a></dd><dt>Since</dt><dd><p>2.8.7</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if key is not of type string</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>The position is returned thinking at the string as an array of bits from left to right
where the first byte most significant bit is at position 0, the second byte most significant
big is at position 8 and so forth.
The range is interpreted as a range of bytes and not a range of bits, so start=0 and end=2
means to look at the first three bytes.
If we look for set bits (the bit argument is 1) and the string is empty or composed of just
zero bytes, -1 is returned.
If we look for clear bits (the bit argument is 0) and the string only contains bit set to 1,
the function returns the first bit not part of the string on the right. So if the string is
tree bytes set to the value 0xff the command BITPOS key 0 will return 24, since up to bit 23
all the bits are 1.
Basically the function consider the right of the string as padded with zeros if you look for
clear bits and specify no range or the start argument <b>only</b>.
However this behavior changes if you are looking for clear bits and specify a range with both
start and stop. If no clear bit is found in the specified range, the function returns -1 as
the user specified a clear range and there are no 0 bits in that range.</p></span></dd></dl></div></li><li class="indented0 " name="scala.AnyRef#clone" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="clone():Object"></a><a id="clone():AnyRef"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#clone():Object" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">clone</span><span class="params">()</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/AnyRef.html#scala.AnyRef" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Attributes</dt><dd>protected[<span name="java.lang" class="extype">lang</span>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">classOf[java.lang.CloneNotSupportedException]</span></span>)</span> <span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="scredis.commands.ClusterCommands#clusterAddSlots" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="clusterAddSlots(slot:Long,slots:Long*):scala.concurrent.Future[Unit]"></a><a id="clusterAddSlots(Long,Long*):Future[Unit]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#clusterAddSlots(slot:Long,slots:Long*):scala.concurrent.Future[Unit]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">clusterAddSlots</span><span class="params">(<span name="slot">slot: <a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a></span>, <span name="slots">slots: <a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a>*</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span></span><p class="shortcomment cmt">Assign new hash slots to receiving node
</p><div class="fullcomment"><div class="comment cmt"><p>Assign new hash slots to receiving node
</p></div><dl class="paramcmts block"><dt class="param">slot</dt><dd class="cmt"><p>a slot</p></dd><dt class="param">slots</dt><dd class="cmt"><p>more slots</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/ClusterCommands.html" name="scredis.commands.ClusterCommands" id="scredis.commands.ClusterCommands" class="extype">ClusterCommands</a></dd><dt>Since</dt><dd><p>3.0.0</p></dd></dl></div></li><li class="indented0 " name="scredis.commands.ClusterCommands#clusterCountFailureReports" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="clusterCountFailureReports(nodeId:String):scala.concurrent.Future[Long]"></a><a id="clusterCountFailureReports(String):Future[Long]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#clusterCountFailureReports(nodeId:String):scala.concurrent.Future[Long]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">clusterCountFailureReports</span><span class="params">(<span name="nodeId">nodeId: <span name="scala.Predef.String" class="extype">String</span></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a>]</span></span><p class="shortcomment cmt">Return the number of failure reports active for a given node.</p><div class="fullcomment"><div class="comment cmt"><p>Return the number of failure reports active for a given node.
</p></div><dl class="paramcmts block"><dt class="param">nodeId</dt><dd class="cmt"><p>node to get failures for</p></dd><dt>returns</dt><dd class="cmt"><p>the number of active failure reports for the node</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/ClusterCommands.html" name="scredis.commands.ClusterCommands" id="scredis.commands.ClusterCommands" class="extype">ClusterCommands</a></dd><dt>Since</dt><dd><p>3.0.0</p></dd></dl></div></li><li class="indented0 " name="scredis.commands.ClusterCommands#clusterCountKeysInSlot" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="clusterCountKeysInSlot(slot:Long):scala.concurrent.Future[Long]"></a><a id="clusterCountKeysInSlot(Long):Future[Long]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#clusterCountKeysInSlot(slot:Long):scala.concurrent.Future[Long]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">clusterCountKeysInSlot</span><span class="params">(<span name="slot">slot: <a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a>]</span></span><p class="shortcomment cmt">Return the number of local keys in the specified hash slot.</p><div class="fullcomment"><div class="comment cmt"><p>Return the number of local keys in the specified hash slot.
</p></div><dl class="paramcmts block"><dt class="param">slot</dt><dd class="cmt"><p>slot to count keys in</p></dd><dt>returns</dt><dd class="cmt"><p>the number of local keys in the specified hash slot</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/ClusterCommands.html" name="scredis.commands.ClusterCommands" id="scredis.commands.ClusterCommands" class="extype">ClusterCommands</a></dd><dt>Since</dt><dd><p>3.0.0</p></dd></dl></div></li><li class="indented0 " name="scredis.commands.ClusterCommands#clusterDelSlots" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="clusterDelSlots(slot:Long,slots:Long*):scala.concurrent.Future[Unit]"></a><a id="clusterDelSlots(Long,Long*):Future[Unit]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#clusterDelSlots(slot:Long,slots:Long*):scala.concurrent.Future[Unit]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">clusterDelSlots</span><span class="params">(<span name="slot">slot: <a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a></span>, <span name="slots">slots: <a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a>*</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span></span><p class="shortcomment cmt">Set hash slots as unbound in receiving node.</p><div class="fullcomment"><div class="comment cmt"><p>Set hash slots as unbound in receiving node.
</p></div><dl class="paramcmts block"><dt class="param">slot</dt><dd class="cmt"><p>a slot</p></dd><dt class="param">slots</dt><dd class="cmt"><p>more slots</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/ClusterCommands.html" name="scredis.commands.ClusterCommands" id="scredis.commands.ClusterCommands" class="extype">ClusterCommands</a></dd><dt>Since</dt><dd><p>3.0.0</p></dd></dl></div></li><li class="indented0 " name="scredis.commands.ClusterCommands#clusterFailover" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="clusterFailover():scala.concurrent.Future[Unit]"></a><a id="clusterFailover():Future[Unit]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#clusterFailover():scala.concurrent.Future[Unit]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">clusterFailover</span><span class="params">()</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span></span><p class="shortcomment cmt">Forces a slave to perform a manual failover of its master.</p><div class="fullcomment"><div class="comment cmt"><p>Forces a slave to perform a manual failover of its master.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/ClusterCommands.html" name="scredis.commands.ClusterCommands" id="scredis.commands.ClusterCommands" class="extype">ClusterCommands</a></dd></dl></div></li><li class="indented0 " name="scredis.commands.ClusterCommands#clusterFailoverForce" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="clusterFailoverForce():scala.concurrent.Future[Unit]"></a><a id="clusterFailoverForce():Future[Unit]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#clusterFailoverForce():scala.concurrent.Future[Unit]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">clusterFailoverForce</span><span class="params">()</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span></span><p class="shortcomment cmt">Forces a slave to perform a manual failover of its master.</p><div class="fullcomment"><div class="comment cmt"><p>Forces a slave to perform a manual failover of its master.</p><p>FORCE option: manual failover when the master is down.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/ClusterCommands.html" name="scredis.commands.ClusterCommands" id="scredis.commands.ClusterCommands" class="extype">ClusterCommands</a></dd><dt>Since</dt><dd><p>3.0.0</p></dd></dl></div></li><li class="indented0 " name="scredis.commands.ClusterCommands#clusterFailoverTakeover" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="clusterFailoverTakeover():scala.concurrent.Future[Unit]"></a><a id="clusterFailoverTakeover():Future[Unit]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#clusterFailoverTakeover():scala.concurrent.Future[Unit]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">clusterFailoverTakeover</span><span class="params">()</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span></span><p class="shortcomment cmt">Forces a slave to perform a manual failover of its master.</p><div class="fullcomment"><div class="comment cmt"><p>Forces a slave to perform a manual failover of its master.</p><p>TAKEOVER option: manual failover without cluster consensus.
TAKEOVER option implies everything FORCE implies, but also does not uses any cluster authorization
in order to failover.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/ClusterCommands.html" name="scredis.commands.ClusterCommands" id="scredis.commands.ClusterCommands" class="extype">ClusterCommands</a></dd><dt>Since</dt><dd><p>3.0.0</p></dd></dl></div></li><li class="indented0 " name="scredis.commands.ClusterCommands#clusterForget" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="clusterForget(nodeId:String):scala.concurrent.Future[Unit]"></a><a id="clusterForget(String):Future[Unit]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#clusterForget(nodeId:String):scala.concurrent.Future[Unit]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">clusterForget</span><span class="params">(<span name="nodeId">nodeId: <span name="scala.Predef.String" class="extype">String</span></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span></span><p class="shortcomment cmt">Remove a node from the nodes table.</p><div class="fullcomment"><div class="comment cmt"><p>Remove a node from the nodes table.
</p></div><dl class="paramcmts block"><dt class="param">nodeId</dt><dd class="cmt"><p>node to remove</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/ClusterCommands.html" name="scredis.commands.ClusterCommands" id="scredis.commands.ClusterCommands" class="extype">ClusterCommands</a></dd><dt>Since</dt><dd><p>3.0.0</p></dd></dl></div></li><li class="indented0 " name="scredis.commands.ClusterCommands#clusterGetKeysInSlot" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="clusterGetKeysInSlot(slot:Long,count:Long):scala.concurrent.Future[Set[String]]"></a><a id="clusterGetKeysInSlot(Long,Long):Future[Set[String]]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#clusterGetKeysInSlot(slot:Long,count:Long):scala.concurrent.Future[Set[String]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">clusterGetKeysInSlot</span><span class="params">(<span name="slot">slot: <a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a></span>, <span name="count">count: <a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="scala.Predef.Set" class="extype">Set</span>[<span name="scala.Predef.String" class="extype">String</span>]]</span></span><p class="shortcomment cmt">Return local key names in the specified hash slot.</p><div class="fullcomment"><div class="comment cmt"><p>Return local key names in the specified hash slot.
</p></div><dl class="paramcmts block"><dt class="param">slot</dt><dd class="cmt"><p>slot to get key names from</p></dd><dt class="param">count</dt><dd class="cmt"><p>number of keys to return</p></dd><dt>returns</dt><dd class="cmt"><p>local key names in the specified hash slot</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/ClusterCommands.html" name="scredis.commands.ClusterCommands" id="scredis.commands.ClusterCommands" class="extype">ClusterCommands</a></dd><dt>Since</dt><dd><p>3.0.0</p></dd></dl></div></li><li class="indented0 " name="scredis.commands.ClusterCommands#clusterInfo" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="clusterInfo():scala.concurrent.Future[Map[String,String]]"></a><a id="clusterInfo():Future[Map[String,String]]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#clusterInfo():scala.concurrent.Future[Map[String,String]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">clusterInfo</span><span class="params">()</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="scala.Predef.Map" class="extype">Map</span>[<span name="scala.Predef.String" class="extype">String</span>, <span name="scala.Predef.String" class="extype">String</span>]]</span></span><p class="shortcomment cmt">Provides info about Redis Cluster node state.</p><div class="fullcomment"><div class="comment cmt"><p>Provides info about Redis Cluster node state.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>Key-value mapping of Redis Cluster vital parameters.</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/ClusterCommands.html" name="scredis.commands.ClusterCommands" id="scredis.commands.ClusterCommands" class="extype">ClusterCommands</a></dd><dt>Since</dt><dd><p>3.0.0</p></dd></dl></div></li><li class="indented0 " name="scredis.commands.ClusterCommands#clusterKeyslot" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="clusterKeyslot(key:String):scala.concurrent.Future[Long]"></a><a id="clusterKeyslot(String):Future[Long]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#clusterKeyslot(key:String):scala.concurrent.Future[Long]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">clusterKeyslot</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a>]</span></span><p class="shortcomment cmt">Returns the hash slot of the specified key.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the hash slot of the specified key.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/ClusterCommands.html" name="scredis.commands.ClusterCommands" id="scredis.commands.ClusterCommands" class="extype">ClusterCommands</a></dd><dt>Since</dt><dd><p>3.0.0</p></dd></dl></div></li><li class="indented0 " name="scredis.commands.ClusterCommands#clusterMeet" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="clusterMeet(ip:String,port:Long):scala.concurrent.Future[Unit]"></a><a id="clusterMeet(String,Long):Future[Unit]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#clusterMeet(ip:String,port:Long):scala.concurrent.Future[Unit]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">clusterMeet</span><span class="params">(<span name="ip">ip: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="port">port: <a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span></span><p class="shortcomment cmt">Force a node cluster to handshake with another node.</p><div class="fullcomment"><div class="comment cmt"><p>Force a node cluster to handshake with another node.
</p></div><dl class="paramcmts block"><dt class="param">ip</dt><dd class="cmt"><p>ip address of</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/ClusterCommands.html" name="scredis.commands.ClusterCommands" id="scredis.commands.ClusterCommands" class="extype">ClusterCommands</a></dd><dt>Since</dt><dd><p>3.0.0</p></dd></dl></div></li><li class="indented0 " name="scredis.commands.ClusterCommands#clusterNodes" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="clusterNodes():scala.concurrent.Future[Seq[scredis.ClusterNode]]"></a><a id="clusterNodes():Future[Seq[ClusterNode]]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#clusterNodes():scala.concurrent.Future[Seq[scredis.ClusterNode]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">clusterNodes</span><span class="params">()</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="scala.Seq" class="extype">Seq</span>[<a href="package$$ClusterNode.html" name="scredis.ClusterNode" id="scredis.ClusterNode" class="extype">ClusterNode</a>]]</span></span><p class="shortcomment cmt">Get Cluster config for the node.</p><div class="fullcomment"><div class="comment cmt"><p>Get Cluster config for the node.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/ClusterCommands.html" name="scredis.commands.ClusterCommands" id="scredis.commands.ClusterCommands" class="extype">ClusterCommands</a></dd><dt>Since</dt><dd><p>3.0.0</p></dd></dl></div></li><li class="indented0 " name="scredis.commands.ClusterCommands#clusterReplicate" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="clusterReplicate(nodeId:String):scala.concurrent.Future[Unit]"></a><a id="clusterReplicate(String):Future[Unit]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#clusterReplicate(nodeId:String):scala.concurrent.Future[Unit]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">clusterReplicate</span><span class="params">(<span name="nodeId">nodeId: <span name="scala.Predef.String" class="extype">String</span></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span></span><p class="shortcomment cmt">Reconfigure a node as a slave of the specified master node.</p><div class="fullcomment"><div class="comment cmt"><p>Reconfigure a node as a slave of the specified master node.
</p></div><dl class="paramcmts block"><dt class="param">nodeId</dt><dd class="cmt"><p>master node to replicate</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/ClusterCommands.html" name="scredis.commands.ClusterCommands" id="scredis.commands.ClusterCommands" class="extype">ClusterCommands</a></dd><dt>Since</dt><dd><p>3.0.0</p></dd></dl></div></li><li class="indented0 " name="scredis.commands.ClusterCommands#clusterReset" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="clusterReset():scala.concurrent.Future[Unit]"></a><a id="clusterReset():Future[Unit]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#clusterReset():scala.concurrent.Future[Unit]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">clusterReset</span><span class="params">()</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span></span><p class="shortcomment cmt">Reset a Redis Cluster node.</p><div class="fullcomment"><div class="comment cmt"><p>Reset a Redis Cluster node.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/ClusterCommands.html" name="scredis.commands.ClusterCommands" id="scredis.commands.ClusterCommands" class="extype">ClusterCommands</a></dd><dt>Since</dt><dd><p>3.0.0</p></dd></dl></div></li><li class="indented0 " name="scredis.commands.ClusterCommands#clusterResetHard" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="clusterResetHard():scala.concurrent.Future[Unit]"></a><a id="clusterResetHard():Future[Unit]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#clusterResetHard():scala.concurrent.Future[Unit]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">clusterResetHard</span><span class="params">()</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span></span><p class="shortcomment cmt">Reset a Redis Cluster node with HARD option.</p><div class="fullcomment"><div class="comment cmt"><p>Reset a Redis Cluster node with HARD option.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/ClusterCommands.html" name="scredis.commands.ClusterCommands" id="scredis.commands.ClusterCommands" class="extype">ClusterCommands</a></dd><dt>Since</dt><dd><p>3.0.0</p></dd></dl></div></li><li class="indented0 " name="scredis.commands.ClusterCommands#clusterSaveConfig" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="clusterSaveConfig():scala.concurrent.Future[Unit]"></a><a id="clusterSaveConfig():Future[Unit]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#clusterSaveConfig():scala.concurrent.Future[Unit]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">clusterSaveConfig</span><span class="params">()</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span></span><p class="shortcomment cmt">Forces the node to save cluster state on disk.</p><div class="fullcomment"><div class="comment cmt"><p>Forces the node to save cluster state on disk.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/ClusterCommands.html" name="scredis.commands.ClusterCommands" id="scredis.commands.ClusterCommands" class="extype">ClusterCommands</a></dd><dt>Since</dt><dd><p>3.0.0</p></dd></dl></div></li><li class="indented0 " name="scredis.commands.ClusterCommands#clusterSetConfigEpoch" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="clusterSetConfigEpoch(configEpoch:Long):scala.concurrent.Future[Unit]"></a><a id="clusterSetConfigEpoch(Long):Future[Unit]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#clusterSetConfigEpoch(configEpoch:Long):scala.concurrent.Future[Unit]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">clusterSetConfigEpoch</span><span class="params">(<span name="configEpoch">configEpoch: <a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span></span><p class="shortcomment cmt">Set the configuration epoch in a new node.</p><div class="fullcomment"><div class="comment cmt"><p>Set the configuration epoch in a new node.
</p></div><dl class="paramcmts block"><dt class="param">configEpoch</dt><dd class="cmt"><p>the config epoch to set</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/ClusterCommands.html" name="scredis.commands.ClusterCommands" id="scredis.commands.ClusterCommands" class="extype">ClusterCommands</a></dd><dt>Since</dt><dd><p>3.0.0</p></dd></dl></div></li><li class="indented0 " name="scredis.commands.ClusterCommands#clusterSetSlotImporting" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="clusterSetSlotImporting(slot:Long,sourceNode:String):scala.concurrent.Future[Unit]"></a><a id="clusterSetSlotImporting(Long,String):Future[Unit]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#clusterSetSlotImporting(slot:Long,sourceNode:String):scala.concurrent.Future[Unit]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">clusterSetSlotImporting</span><span class="params">(<span name="slot">slot: <a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a></span>, <span name="sourceNode">sourceNode: <span name="scala.Predef.String" class="extype">String</span></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span></span><p class="shortcomment cmt">Set a hash slot in importing state.</p><div class="fullcomment"><div class="comment cmt"><p>Set a hash slot in importing state.
</p></div><dl class="paramcmts block"><dt class="param">slot</dt><dd class="cmt"><p>slot to import</p></dd><dt class="param">sourceNode</dt><dd class="cmt"><p>node to import from</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/ClusterCommands.html" name="scredis.commands.ClusterCommands" id="scredis.commands.ClusterCommands" class="extype">ClusterCommands</a></dd><dt>Since</dt><dd><p>3.0.0</p></dd></dl></div></li><li class="indented0 " name="scredis.commands.ClusterCommands#clusterSetSlotMigrating" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="clusterSetSlotMigrating(slot:Long,destinationNode:String):scala.concurrent.Future[Unit]"></a><a id="clusterSetSlotMigrating(Long,String):Future[Unit]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#clusterSetSlotMigrating(slot:Long,destinationNode:String):scala.concurrent.Future[Unit]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">clusterSetSlotMigrating</span><span class="params">(<span name="slot">slot: <a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a></span>, <span name="destinationNode">destinationNode: <span name="scala.Predef.String" class="extype">String</span></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span></span><p class="shortcomment cmt">Set a hash slot in migrating state.</p><div class="fullcomment"><div class="comment cmt"><p>Set a hash slot in migrating state.
</p></div><dl class="paramcmts block"><dt class="param">slot</dt><dd class="cmt"><p>slot to migrate</p></dd><dt class="param">destinationNode</dt><dd class="cmt"><p>node to migrate to</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/ClusterCommands.html" name="scredis.commands.ClusterCommands" id="scredis.commands.ClusterCommands" class="extype">ClusterCommands</a></dd><dt>Since</dt><dd><p>3.0.0</p></dd></dl></div></li><li class="indented0 " name="scredis.commands.ClusterCommands#clusterSetSlotNode" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="clusterSetSlotNode(slot:Long,nodeId:String):scala.concurrent.Future[Unit]"></a><a id="clusterSetSlotNode(Long,String):Future[Unit]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#clusterSetSlotNode(slot:Long,nodeId:String):scala.concurrent.Future[Unit]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">clusterSetSlotNode</span><span class="params">(<span name="slot">slot: <a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a></span>, <span name="nodeId">nodeId: <span name="scala.Predef.String" class="extype">String</span></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span></span><p class="shortcomment cmt">Bind the hash slot to a different node.</p><div class="fullcomment"><div class="comment cmt"><p>Bind the hash slot to a different node.
</p></div><dl class="paramcmts block"><dt class="param">slot</dt><dd class="cmt"><p>slot to associate with node</p></dd><dt class="param">nodeId</dt><dd class="cmt"><p>node to be associated with slot</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/ClusterCommands.html" name="scredis.commands.ClusterCommands" id="scredis.commands.ClusterCommands" class="extype">ClusterCommands</a></dd><dt>Since</dt><dd><p>3.0.0</p></dd></dl></div></li><li class="indented0 " name="scredis.commands.ClusterCommands#clusterSetSlotStable" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="clusterSetSlotStable(slot:Long):scala.concurrent.Future[Unit]"></a><a id="clusterSetSlotStable(Long):Future[Unit]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#clusterSetSlotStable(slot:Long):scala.concurrent.Future[Unit]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">clusterSetSlotStable</span><span class="params">(<span name="slot">slot: <a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span></span><p class="shortcomment cmt">Clear any importing / migrating state from hash slot.</p><div class="fullcomment"><div class="comment cmt"><p>Clear any importing / migrating state from hash slot.
</p></div><dl class="paramcmts block"><dt class="param">slot</dt><dd class="cmt"><p>slot to clear of migrating/importing state</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/ClusterCommands.html" name="scredis.commands.ClusterCommands" id="scredis.commands.ClusterCommands" class="extype">ClusterCommands</a></dd><dt>Since</dt><dd><p>3.0.0</p></dd></dl></div></li><li class="indented0 " name="scredis.commands.ClusterCommands#clusterSlaves" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="clusterSlaves(nodeId:String):scala.concurrent.Future[Seq[scredis.ClusterNode]]"></a><a id="clusterSlaves(String):Future[Seq[ClusterNode]]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#clusterSlaves(nodeId:String):scala.concurrent.Future[Seq[scredis.ClusterNode]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">clusterSlaves</span><span class="params">(<span name="nodeId">nodeId: <span name="scala.Predef.String" class="extype">String</span></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="scala.Seq" class="extype">Seq</span>[<a href="package$$ClusterNode.html" name="scredis.ClusterNode" id="scredis.ClusterNode" class="extype">ClusterNode</a>]]</span></span><p class="shortcomment cmt">List slave nodes of the specified master node.</p><div class="fullcomment"><div class="comment cmt"><p>List slave nodes of the specified master node.
</p></div><dl class="paramcmts block"><dt class="param">nodeId</dt><dd class="cmt"><p>node to list slave nodes of</p></dd><dt>returns</dt><dd class="cmt"><p>slave nodes of the given master</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/ClusterCommands.html" name="scredis.commands.ClusterCommands" id="scredis.commands.ClusterCommands" class="extype">ClusterCommands</a></dd><dt>Since</dt><dd><p>3.0.0</p></dd></dl></div></li><li class="indented0 " name="scredis.commands.ClusterCommands#clusterSlots" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="clusterSlots():scala.concurrent.Future[List[scredis.ClusterSlotRange]]"></a><a id="clusterSlots():Future[List[ClusterSlotRange]]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#clusterSlots():scala.concurrent.Future[List[scredis.ClusterSlotRange]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">clusterSlots</span><span class="params">()</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="scala.List" class="extype">List</span>[<a href="package$$ClusterSlotRange.html" name="scredis.ClusterSlotRange" id="scredis.ClusterSlotRange" class="extype">ClusterSlotRange</a>]]</span></span><p class="shortcomment cmt">Get array of Cluster slot to node mappings.</p><div class="fullcomment"><div class="comment cmt"><p>Get array of Cluster slot to node mappings.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>List of cluster slot ranges, with respective master and slave nodes.</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/ClusterCommands.html" name="scredis.commands.ClusterCommands" id="scredis.commands.ClusterCommands" class="extype">ClusterCommands</a></dd><dt>Since</dt><dd><p>3.0.0</p></dd></dl></div></li><li class="indented0 " name="scredis.commands.StringCommands#decr" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="decr(key:String):scala.concurrent.Future[Long]"></a><a id="decr(String):Future[Long]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#decr(key:String):scala.concurrent.Future[Long]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">decr</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a>]</span></span><p class="shortcomment cmt">Decrements the integer value of a key by one.</p><div class="fullcomment"><div class="comment cmt"><p>Decrements the integer value of a key by one.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>the key to decrement</p></dd><dt>returns</dt><dd class="cmt"><p>the value of key after the decrement</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/StringCommands.html" name="scredis.commands.StringCommands" id="scredis.commands.StringCommands" class="extype">StringCommands</a></dd><dt>Since</dt><dd><p>1.0.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if the key contains a value of the wrong type or contains a string that cannot be
represented as integer</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>If the key does not exist, it is set to 0 before performing the operation.</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.StringCommands#decrBy" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="decrBy(key:String,decrement:Long):scala.concurrent.Future[Long]"></a><a id="decrBy(String,Long):Future[Long]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#decrBy(key:String,decrement:Long):scala.concurrent.Future[Long]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">decrBy</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="decrement">decrement: <a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a>]</span></span><p class="shortcomment cmt">Decrements the integer value of a key by the given amount.</p><div class="fullcomment"><div class="comment cmt"><p>Decrements the integer value of a key by the given amount.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>the key to decrement</p></dd><dt class="param">decrement</dt><dd class="cmt"><p>the decrement</p></dd><dt>returns</dt><dd class="cmt"><p>the value of key after the decrement</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/StringCommands.html" name="scredis.commands.StringCommands" id="scredis.commands.StringCommands" class="extype">StringCommands</a></dd><dt>Since</dt><dd><p>1.0.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if the key contains a value of the wrong type or contains
a string that cannot be represented as integer</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>If the key does not exist, it is set to 0 before performing the operation.</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.KeyCommands#del" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="del(keys:String*):scala.concurrent.Future[Long]"></a><a id="del(String*):Future[Long]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#del(keys:String*):scala.concurrent.Future[Long]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">del</span><span class="params">(<span name="keys">keys: <span name="scala.Predef.String" class="extype">String</span>*</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a>]</span></span><p class="shortcomment cmt">Deletes one or multiple keys.</p><div class="fullcomment"><div class="comment cmt"><p>Deletes one or multiple keys.
</p></div><dl class="paramcmts block"><dt class="param">keys</dt><dd class="cmt"><p>key(s) to delete</p></dd><dt>returns</dt><dd class="cmt"><p>the number of keys that were deleted</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/KeyCommands.html" name="scredis.commands.KeyCommands" id="scredis.commands.KeyCommands" class="extype">KeyCommands</a></dd><dt>Since</dt><dd><p>1.0.0</p></dd><dt>Note</dt><dd><span class="cmt"><p>a key is ignored if it does not exist</p></span></dd></dl></div></li><li class="indented0 " name="scredis.RedisCluster#dispatcher" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="dispatcher:scala.concurrent.ExecutionContext"></a><a id="dispatcher:ExecutionContext"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#dispatcher:scala.concurrent.ExecutionContext" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">implicit </span> <span class="kind">val</span></span> <span class="symbol"><span class="name">dispatcher</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/ExecutionContext.html#scala.concurrent.ExecutionContext" name="scala.concurrent.ExecutionContext" id="scala.concurrent.ExecutionContext" class="extype">ExecutionContext</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="" name="scredis.RedisCluster" id="scredis.RedisCluster" class="extype">RedisCluster</a> → <a href="io/Connection.html" name="scredis.io.Connection" id="scredis.io.Connection" class="extype">Connection</a></dd></dl></div></li><li class="indented0 " name="scredis.commands.KeyCommands#dump" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="dump(key:String):scala.concurrent.Future[Option[Array[Byte]]]"></a><a id="dump(String):Future[Option[Array[Byte]]]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#dump(key:String):scala.concurrent.Future[Option[Array[Byte]]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">dump</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Option.html#scala.Option" name="scala.Option" id="scala.Option" class="extype">Option</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Array.html#scala.Array" name="scala.Array" id="scala.Array" class="extype">Array</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Byte.html#scala.Byte" name="scala.Byte" id="scala.Byte" class="extype">Byte</a>]]]</span></span><p class="shortcomment cmt">Returns a serialized version of the value stored at the specified key.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a serialized version of the value stored at the specified key.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>key to dump</p></dd><dt>returns</dt><dd class="cmt"><p>the serialized value or <code>None</code> if the key does not exist</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/KeyCommands.html" name="scredis.commands.KeyCommands" id="scredis.commands.KeyCommands" class="extype">KeyCommands</a></dd><dt>Since</dt><dd><p>2.6.0</p></dd></dl></div></li><li class="indented0 " name="scala.AnyRef#eq" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="eq(x$1:AnyRef):Boolean"></a><a id="eq(AnyRef):Boolean"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#eq(x$1:AnyRef):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">eq</span><span class="params">(<span name="arg0">arg0: <a href="https://www.scala-lang.org/api/2.13.1/scala/AnyRef.html#scala.AnyRef" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div></li><li class="indented0 " name="scala.AnyRef#equals" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="equals(x$1:Object):Boolean"></a><a id="equals(AnyRef):Boolean"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#equals(x$1:Object):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">equals</span><span class="params">(<span name="arg0">arg0: <a href="https://www.scala-lang.org/api/2.13.1/scala/AnyRef.html#scala.AnyRef" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="scredis.commands.ScriptingCommands#eval" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="eval[R,W1,W2](script:String,keys:Seq[W1],args:Seq[W2])(implicitevidence$1:scredis.protocol.Decoder[R],implicitevidence$2:scredis.serialization.Writer[W1],implicitevidence$3:scredis.serialization.Writer[W2]):scala.concurrent.Future[R]"></a><a id="eval[R,W1,W2](String,Seq[W1],Seq[W2])(Decoder[R],Writer[W1],Writer[W2]):Future[R]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#eval[R,W1,W2](script:String,keys:Seq[W1],args:Seq[W2])(implicitevidence$1:scredis.protocol.Decoder[R],implicitevidence$2:scredis.serialization.Writer[W1],implicitevidence$3:scredis.serialization.Writer[W2]):scala.concurrent.Future[R]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">eval</span><span class="tparams">[<span name="R">R</span>, <span name="W1">W1</span>, <span name="W2">W2</span>]</span><span class="params">(<span name="script">script: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="keys">keys: <span name="scala.Seq" class="extype">Seq</span>[<span name="scredis.commands.ScriptingCommands.eval.W1" class="extype">W1</span>] = <span class="symbol">Nil</span></span>, <span name="args">args: <span name="scala.Seq" class="extype">Seq</span>[<span name="scredis.commands.ScriptingCommands.eval.W2" class="extype">W2</span>] = <span class="symbol">Nil</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="protocol/index.html#Decoder[X]=PartialFunction[scredis.protocol.Response,X]" name="scredis.protocol.Decoder" id="scredis.protocol.Decoder" class="extmbr">Decoder</a>[<span name="scredis.commands.ScriptingCommands.eval.R" class="extype">R</span>]</span>, <span name="arg1">arg1: <a href="serialization/Writer.html" name="scredis.serialization.Writer" id="scredis.serialization.Writer" class="extype">Writer</a>[<span name="scredis.commands.ScriptingCommands.eval.W1" class="extype">W1</span>]</span>, <span name="arg2">arg2: <a href="serialization/Writer.html" name="scredis.serialization.Writer" id="scredis.serialization.Writer" class="extype">Writer</a>[<span name="scredis.commands.ScriptingCommands.eval.W2" class="extype">W2</span>]</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="scredis.commands.ScriptingCommands.eval.R" class="extype">R</span>]</span></span><p class="shortcomment cmt">Executes a Lua script that does not require any keys or arguments.</p><div class="fullcomment"><div class="comment cmt"><p>Executes a Lua script that does not require any keys or arguments.
</p></div><dl class="paramcmts block"><dt class="param">script</dt><dd class="cmt"><p>the LUA script</p></dd><dt class="param">keys</dt><dd class="cmt"><p>keys to be used in the script</p></dd><dt class="param">args</dt><dd class="cmt"><p>arguments to be used in the script</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/ScriptingCommands.html" name="scredis.commands.ScriptingCommands" id="scredis.commands.ScriptingCommands" class="extype">ScriptingCommands</a></dd><dt>Since</dt><dd><p>2.6.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if an error occurs while running the script</p></span><span class="cmt"><p><span name="[[scredis.exceptions.RedisProtocolException]]" class="extype"><code>[[scredis.exceptions.RedisProtocolException]]</code></span> if the result could not be decoded by provided <code>Decoder</code></p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.ScriptingCommands#evalSHA" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="evalSHA[R,W1,W2](sha1:String,keys:Seq[W1],args:Seq[W2])(implicitevidence$4:scredis.protocol.Decoder[R],implicitevidence$5:scredis.serialization.Writer[W1],implicitevidence$6:scredis.serialization.Writer[W2]):scala.concurrent.Future[R]"></a><a id="evalSHA[R,W1,W2](String,Seq[W1],Seq[W2])(Decoder[R],Writer[W1],Writer[W2]):Future[R]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#evalSHA[R,W1,W2](sha1:String,keys:Seq[W1],args:Seq[W2])(implicitevidence$4:scredis.protocol.Decoder[R],implicitevidence$5:scredis.serialization.Writer[W1],implicitevidence$6:scredis.serialization.Writer[W2]):scala.concurrent.Future[R]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">evalSHA</span><span class="tparams">[<span name="R">R</span>, <span name="W1">W1</span>, <span name="W2">W2</span>]</span><span class="params">(<span name="sha1">sha1: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="keys">keys: <span name="scala.Seq" class="extype">Seq</span>[<span name="scredis.commands.ScriptingCommands.evalSHA.W1" class="extype">W1</span>] = <span class="symbol">Nil</span></span>, <span name="args">args: <span name="scala.Seq" class="extype">Seq</span>[<span name="scredis.commands.ScriptingCommands.evalSHA.W2" class="extype">W2</span>] = <span class="symbol">Nil</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="protocol/index.html#Decoder[X]=PartialFunction[scredis.protocol.Response,X]" name="scredis.protocol.Decoder" id="scredis.protocol.Decoder" class="extmbr">Decoder</a>[<span name="scredis.commands.ScriptingCommands.evalSHA.R" class="extype">R</span>]</span>, <span name="arg1">arg1: <a href="serialization/Writer.html" name="scredis.serialization.Writer" id="scredis.serialization.Writer" class="extype">Writer</a>[<span name="scredis.commands.ScriptingCommands.evalSHA.W1" class="extype">W1</span>]</span>, <span name="arg2">arg2: <a href="serialization/Writer.html" name="scredis.serialization.Writer" id="scredis.serialization.Writer" class="extype">Writer</a>[<span name="scredis.commands.ScriptingCommands.evalSHA.W2" class="extype">W2</span>]</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="scredis.commands.ScriptingCommands.evalSHA.R" class="extype">R</span>]</span></span><p class="shortcomment cmt">Executes a cached Lua script that does not require any keys or arguments by its SHA1 digest.</p><div class="fullcomment"><div class="comment cmt"><p>Executes a cached Lua script that does not require any keys or arguments by its SHA1 digest.
</p></div><dl class="paramcmts block"><dt class="param">sha1</dt><dd class="cmt"><p>the SHA1 digest</p></dd><dt class="param">keys</dt><dd class="cmt"><p>keys to be used in the script</p></dd><dt class="param">args</dt><dd class="cmt"><p>arguments to be used in the script</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/ScriptingCommands.html" name="scredis.commands.ScriptingCommands" id="scredis.commands.ScriptingCommands" class="extype">ScriptingCommands</a></dd><dt>Since</dt><dd><p>2.6.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if there is no script corresponding to the provided SHA1 digest or if an error
occurs while running the script</p></span><span class="cmt"><p><span name="[[scredis.exceptions.RedisProtocolException]]" class="extype"><code>[[scredis.exceptions.RedisProtocolException]]</code></span> if the result could not be decoded by provided <code>Decoder</code></p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.KeyCommands#exists" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="exists(key:String):scala.concurrent.Future[Boolean]"></a><a id="exists(String):Future[Boolean]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#exists(key:String):scala.concurrent.Future[Boolean]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">exists</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a>]</span></span><p class="shortcomment cmt">Determines if a key exists.</p><div class="fullcomment"><div class="comment cmt"><p>Determines if a key exists.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>key to check for existence</p></dd><dt>returns</dt><dd class="cmt"><p><b>true</b> if the key exists, <b>false</b> otherwise</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/KeyCommands.html" name="scredis.commands.KeyCommands" id="scredis.commands.KeyCommands" class="extype">KeyCommands</a></dd><dt>Since</dt><dd><p>1.0.0</p></dd></dl></div></li><li class="indented0 " name="scredis.commands.KeyCommands#expire" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="expire(key:String,ttlSeconds:Int):scala.concurrent.Future[Boolean]"></a><a id="expire(String,Int):Future[Boolean]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#expire(key:String,ttlSeconds:Int):scala.concurrent.Future[Boolean]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">expire</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="ttlSeconds">ttlSeconds: <a href="https://www.scala-lang.org/api/2.13.1/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a>]</span></span><p class="shortcomment cmt">Sets a key's time to live in seconds.</p><div class="fullcomment"><div class="comment cmt"><p>Sets a key's time to live in seconds.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>key to expire</p></dd><dt class="param">ttlSeconds</dt><dd class="cmt"><p>time-to-live in seconds</p></dd><dt>returns</dt><dd class="cmt"><p><b>true</b> if the ttl was set, <b>false</b> if key does not exist or
the timeout could not be set</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/KeyCommands.html" name="scredis.commands.KeyCommands" id="scredis.commands.KeyCommands" class="extype">KeyCommands</a></dd><dt>Since</dt><dd><p>1.0.0</p></dd></dl></div></li><li class="indented0 " name="scredis.commands.KeyCommands#expireAt" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="expireAt(key:String,timestamp:Long):scala.concurrent.Future[Boolean]"></a><a id="expireAt(String,Long):Future[Boolean]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#expireAt(key:String,timestamp:Long):scala.concurrent.Future[Boolean]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">expireAt</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="timestamp">timestamp: <a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a>]</span></span><p class="shortcomment cmt">Sets the expiration for a key as a UNIX timestamp.</p><div class="fullcomment"><div class="comment cmt"><p>Sets the expiration for a key as a UNIX timestamp.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>key to expire</p></dd><dt class="param">timestamp</dt><dd class="cmt"><p>UNIX timestamp at which the key should expire</p></dd><dt>returns</dt><dd class="cmt"><p><b>true</b> if the ttl was set, <b>false</b> if key does not exist or
the timeout could not be set</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/KeyCommands.html" name="scredis.commands.KeyCommands" id="scredis.commands.KeyCommands" class="extype">KeyCommands</a></dd><dt>Since</dt><dd><p>1.2.0</p></dd></dl></div></li><li class="indented0 " name="scala.AnyRef#finalize" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="finalize():Unit"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#finalize():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">finalize</span><span class="params">()</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Attributes</dt><dd>protected[<span name="java.lang" class="extype">lang</span>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="symbol">classOf[java.lang.Throwable]</span></span>)</span> </dd></dl></div></li><li class="indented0 " name="scredis.commands.StringCommands#get" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="get[R](key:String)(implicitevidence$2:scredis.serialization.Reader[R]):scala.concurrent.Future[Option[R]]"></a><a id="get[R](String)(Reader[R]):Future[Option[R]]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#get[R](key:String)(implicitevidence$2:scredis.serialization.Reader[R]):scala.concurrent.Future[Option[R]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">get</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Reader.html" name="scredis.serialization.Reader" id="scredis.serialization.Reader" class="extype">Reader</a>[<span name="scredis.commands.StringCommands.get.R" class="extype">R</span>]</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Option.html#scala.Option" name="scala.Option" id="scala.Option" class="extype">Option</a>[<span name="scredis.commands.StringCommands.get.R" class="extype">R</span>]]</span></span><p class="shortcomment cmt">Returns the value stored at key.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the value stored at key.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>the target key</p></dd><dt>returns</dt><dd class="cmt"><p>value stored at key, or <code>None</code> if the key does not exist</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/StringCommands.html" name="scredis.commands.StringCommands" id="scredis.commands.StringCommands" class="extype">StringCommands</a></dd><dt>Since</dt><dd><p>1.0.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if the value stored at key is not of type string</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.StringCommands#getBit" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="getBit(key:String,offset:Long):scala.concurrent.Future[Boolean]"></a><a id="getBit(String,Long):Future[Boolean]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#getBit(key:String,offset:Long):scala.concurrent.Future[Boolean]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">getBit</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="offset">offset: <a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a>]</span></span><p class="shortcomment cmt">Returns the bit value at offset in the string value stored at key.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the bit value at offset in the string value stored at key.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>the target key</p></dd><dt class="param">offset</dt><dd class="cmt"><p>the position in the string</p></dd><dt>returns</dt><dd class="cmt"><p><b>true</b> if the bit is set to 1, <b>false</b> otherwise</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/StringCommands.html" name="scredis.commands.StringCommands" id="scredis.commands.StringCommands" class="extype">StringCommands</a></dd><dt>Since</dt><dd><p>2.2.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if the value stored at key is not of type string</p></span></dd></dl></div></li><li class="indented0 " name="scala.AnyRef#getClass" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="getClass():Class[_]"></a><a id="getClass():Class[_&lt;:AnyRef]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#getClass():Class[_]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">getClass</span><span class="params">()</span><span class="result">: <span name="java.lang.Class" class="extype">Class</span>[_ &lt;: <a href="https://www.scala-lang.org/api/2.13.1/scala/AnyRef.html#scala.AnyRef" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a>]</span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd><dt>Annotations</dt><dd><span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="scredis.commands.StringCommands#getRange" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="getRange[R](key:String,start:Long,stop:Long)(implicitevidence$3:scredis.serialization.Reader[R]):scala.concurrent.Future[R]"></a><a id="getRange[R](String,Long,Long)(Reader[R]):Future[R]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#getRange[R](key:String,start:Long,stop:Long)(implicitevidence$3:scredis.serialization.Reader[R]):scala.concurrent.Future[R]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">getRange</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="start">start: <a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a></span>, <span name="stop">stop: <a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Reader.html" name="scredis.serialization.Reader" id="scredis.serialization.Reader" class="extype">Reader</a>[<span name="scredis.commands.StringCommands.getRange.R" class="extype">R</span>]</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="scredis.commands.StringCommands.getRange.R" class="extype">R</span>]</span></span><p class="shortcomment cmt">Returns a substring of the string stored at a key.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a substring of the string stored at a key.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>the target key</p></dd><dt class="param">start</dt><dd class="cmt"><p>the start offset (inclusive)</p></dd><dt class="param">stop</dt><dd class="cmt"><p>the stop offset (inclusive)</p></dd><dt>returns</dt><dd class="cmt"><p>the substring determined by the specified offsets, or the empty string if the key
does not exist</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/StringCommands.html" name="scredis.commands.StringCommands" id="scredis.commands.StringCommands" class="extype">StringCommands</a></dd><dt>Since</dt><dd><p>2.4.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if the value stored at key is not of type string</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>Both offsets are inclusive, i.e. [start, stop]. The function handles out of range
requests by limiting the resulting range to the actual length of the string.</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.StringCommands#getSet" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="getSet[R,W](key:String,value:W)(implicitevidence$4:scredis.serialization.Reader[R],implicitevidence$5:scredis.serialization.Writer[W]):scala.concurrent.Future[Option[R]]"></a><a id="getSet[R,W](String,W)(Reader[R],Writer[W]):Future[Option[R]]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#getSet[R,W](key:String,value:W)(implicitevidence$4:scredis.serialization.Reader[R],implicitevidence$5:scredis.serialization.Writer[W]):scala.concurrent.Future[Option[R]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">getSet</span><span class="tparams">[<span name="R">R</span>, <span name="W">W</span>]</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="value">value: <span name="scredis.commands.StringCommands.getSet.W" class="extype">W</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Reader.html" name="scredis.serialization.Reader" id="scredis.serialization.Reader" class="extype">Reader</a>[<span name="scredis.commands.StringCommands.getSet.R" class="extype">R</span>]</span>, <span name="arg1">arg1: <a href="serialization/Writer.html" name="scredis.serialization.Writer" id="scredis.serialization.Writer" class="extype">Writer</a>[<span name="scredis.commands.StringCommands.getSet.W" class="extype">W</span>]</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Option.html#scala.Option" name="scala.Option" id="scala.Option" class="extype">Option</a>[<span name="scredis.commands.StringCommands.getSet.R" class="extype">R</span>]]</span></span><p class="shortcomment cmt">Sets the string value of a key and return its old value.</p><div class="fullcomment"><div class="comment cmt"><p>Sets the string value of a key and return its old value.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>the target key</p></dd><dt class="param">value</dt><dd class="cmt"><p>the value to set key to</p></dd><dt>returns</dt><dd class="cmt"><p>the old value, or <code>None</code> if the latter did not exist</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/StringCommands.html" name="scredis.commands.StringCommands" id="scredis.commands.StringCommands" class="extype">StringCommands</a></dd><dt>Since</dt><dd><p>1.0.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if the value stored at key is not of type string</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.HashCommands#hDel" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="hDel(key:String,fields:String*):scala.concurrent.Future[Long]"></a><a id="hDel(String,String*):Future[Long]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#hDel(key:String,fields:String*):scala.concurrent.Future[Long]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">hDel</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="fields">fields: <span name="scala.Predef.String" class="extype">String</span>*</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a>]</span></span><p class="shortcomment cmt">Deletes one or more hash fields.</p><div class="fullcomment"><div class="comment cmt"><p>Deletes one or more hash fields.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>key of the hash</p></dd><dt class="param">fields</dt><dd class="cmt"><p>field(s) to be deleted from hash</p></dd><dt>returns</dt><dd class="cmt"><p>the number of fields that were removed from the hash, not including specified but non
existing fields</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/HashCommands.html" name="scredis.commands.HashCommands" id="scredis.commands.HashCommands" class="extype">HashCommands</a></dd><dt>Since</dt><dd><p>2.0.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if the value stored at key is not of type hash</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>Specified fields that do not exist within this hash are ignored. If key does not exist,
it is treated as an empty hash and this command returns 0. Redis versions older than 2.4 can
only remove a field per call.</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.HashCommands#hExists" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="hExists(key:String,field:String):scala.concurrent.Future[Boolean]"></a><a id="hExists(String,String):Future[Boolean]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#hExists(key:String,field:String):scala.concurrent.Future[Boolean]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">hExists</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="field">field: <span name="scala.Predef.String" class="extype">String</span></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a>]</span></span><p class="shortcomment cmt">Determines if a hash field exists.</p><div class="fullcomment"><div class="comment cmt"><p>Determines if a hash field exists.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>hash key</p></dd><dt class="param">field</dt><dd class="cmt"><p>name of the field</p></dd><dt>returns</dt><dd class="cmt"><p><b>true</b> if the hash contains field, <b>false</b> if the hash does not contain it or
the key does not exists</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/HashCommands.html" name="scredis.commands.HashCommands" id="scredis.commands.HashCommands" class="extype">HashCommands</a></dd><dt>Since</dt><dd><p>2.0.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if the value stored at key is not of type hash</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.HashCommands#hGet" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="hGet[R](key:String,field:String)(implicitevidence$1:scredis.serialization.Reader[R]):scala.concurrent.Future[Option[R]]"></a><a id="hGet[R](String,String)(Reader[R]):Future[Option[R]]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#hGet[R](key:String,field:String)(implicitevidence$1:scredis.serialization.Reader[R]):scala.concurrent.Future[Option[R]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">hGet</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="field">field: <span name="scala.Predef.String" class="extype">String</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Reader.html" name="scredis.serialization.Reader" id="scredis.serialization.Reader" class="extype">Reader</a>[<span name="scredis.commands.HashCommands.hGet.R" class="extype">R</span>]</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Option.html#scala.Option" name="scala.Option" id="scala.Option" class="extype">Option</a>[<span name="scredis.commands.HashCommands.hGet.R" class="extype">R</span>]]</span></span><p class="shortcomment cmt">Returns the value of a hash field.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the value of a hash field.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>hash key</p></dd><dt class="param">field</dt><dd class="cmt"><p>field name to retrieve</p></dd><dt>returns</dt><dd class="cmt"><p>the value associated with field name, or <code>None</code> when field is not present in the hash
or key does not exist</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/HashCommands.html" name="scredis.commands.HashCommands" id="scredis.commands.HashCommands" class="extype">HashCommands</a></dd><dt>Since</dt><dd><p>2.0.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if the value stored at key is not of type hash</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.HashCommands#hGetAll" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="hGetAll[R](key:String)(implicitevidence$2:scredis.serialization.Reader[R]):scala.concurrent.Future[Option[Map[String,R]]]"></a><a id="hGetAll[R](String)(Reader[R]):Future[Option[Map[String,R]]]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#hGetAll[R](key:String)(implicitevidence$2:scredis.serialization.Reader[R]):scala.concurrent.Future[Option[Map[String,R]]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">hGetAll</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Reader.html" name="scredis.serialization.Reader" id="scredis.serialization.Reader" class="extype">Reader</a>[<span name="scredis.commands.HashCommands.hGetAll.R" class="extype">R</span>]</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Option.html#scala.Option" name="scala.Option" id="scala.Option" class="extype">Option</a>[<span name="scala.Predef.Map" class="extype">Map</span>[<span name="scala.Predef.String" class="extype">String</span>, <span name="scredis.commands.HashCommands.hGetAll.R" class="extype">R</span>]]]</span></span><p class="shortcomment cmt">Returns all the fields and values in a hash.</p><div class="fullcomment"><div class="comment cmt"><p>Returns all the fields and values in a hash.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>hash key</p></dd><dt>returns</dt><dd class="cmt"><p>key-value pairs stored in hash with key, or <code>None</code> when hash is empty or key does not
exist</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/HashCommands.html" name="scredis.commands.HashCommands" id="scredis.commands.HashCommands" class="extype">HashCommands</a></dd><dt>Since</dt><dd><p>2.0.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if the value stored at key is not of type hash</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.HashCommands#hIncrBy" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="hIncrBy(key:String,field:String,count:Long):scala.concurrent.Future[Long]"></a><a id="hIncrBy(String,String,Long):Future[Long]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#hIncrBy(key:String,field:String,count:Long):scala.concurrent.Future[Long]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">hIncrBy</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="field">field: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="count">count: <a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a>]</span></span><p class="shortcomment cmt">Increments the integer value of a hash field by the given number.</p><div class="fullcomment"><div class="comment cmt"><p>Increments the integer value of a hash field by the given number.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>hash key</p></dd><dt class="param">field</dt><dd class="cmt"><p>field name to increment</p></dd><dt class="param">count</dt><dd class="cmt"><p>increment</p></dd><dt>returns</dt><dd class="cmt"><p>the value at field after the increment operation</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/HashCommands.html" name="scredis.commands.HashCommands" id="scredis.commands.HashCommands" class="extype">HashCommands</a></dd><dt>Since</dt><dd><p>2.0.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if the field does not hold an integer value or if the value stored at key is not of
type hash</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>If key does not exist, a new key holding a hash is created. If field does not exist the
value is set to 0 before the operation is performed.</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.HashCommands#hIncrByFloat" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="hIncrByFloat(key:String,field:String,count:Double):scala.concurrent.Future[Double]"></a><a id="hIncrByFloat(String,String,Double):Future[Double]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#hIncrByFloat(key:String,field:String,count:Double):scala.concurrent.Future[Double]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">hIncrByFloat</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="field">field: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="count">count: <a href="https://www.scala-lang.org/api/2.13.1/scala/Double.html#scala.Double" name="scala.Double" id="scala.Double" class="extype">Double</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Double.html#scala.Double" name="scala.Double" id="scala.Double" class="extype">Double</a>]</span></span><p class="shortcomment cmt">Increments the float value of a hash field by the given amount.</p><div class="fullcomment"><div class="comment cmt"><p>Increments the float value of a hash field by the given amount.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>hash key</p></dd><dt class="param">field</dt><dd class="cmt"><p>field name to increment</p></dd><dt class="param">count</dt><dd class="cmt"><p>increment</p></dd><dt>returns</dt><dd class="cmt"><p>the value at field after the increment operation</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/HashCommands.html" name="scredis.commands.HashCommands" id="scredis.commands.HashCommands" class="extype">HashCommands</a></dd><dt>Since</dt><dd><p>2.6.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if the field does not hold a floating point value or if the value stored at key is
not of type hash</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>If key does not exist, a new key holding a hash is created. If field does not exist the
value is set to 0 before the operation is performed.</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.HashCommands#hKeys" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="hKeys(key:String):scala.concurrent.Future[Set[String]]"></a><a id="hKeys(String):Future[Set[String]]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#hKeys(key:String):scala.concurrent.Future[Set[String]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">hKeys</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="scala.Predef.Set" class="extype">Set</span>[<span name="scala.Predef.String" class="extype">String</span>]]</span></span><p class="shortcomment cmt">Returns all the fields in a hash.</p><div class="fullcomment"><div class="comment cmt"><p>Returns all the fields in a hash.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>hash key</p></dd><dt>returns</dt><dd class="cmt"><p>set of field names or the empty set if the hash is empty or the key does not exist</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/HashCommands.html" name="scredis.commands.HashCommands" id="scredis.commands.HashCommands" class="extype">HashCommands</a></dd><dt>Since</dt><dd><p>2.0.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if the value stored at key is not of type hash</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.HashCommands#hLen" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="hLen(key:String):scala.concurrent.Future[Long]"></a><a id="hLen(String):Future[Long]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#hLen(key:String):scala.concurrent.Future[Long]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">hLen</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a>]</span></span><p class="shortcomment cmt">Returns the number of fields contained in the hash stored at key.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the number of fields contained in the hash stored at key.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>hash key</p></dd><dt>returns</dt><dd class="cmt"><p>number of fields in the hash, or 0 if the key does not exist</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/HashCommands.html" name="scredis.commands.HashCommands" id="scredis.commands.HashCommands" class="extype">HashCommands</a></dd><dt>Since</dt><dd><p>2.0.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if the value stored at key is not of type hash</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.HashCommands#hScan" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="hScan[R](key:String,cursor:Long,matchOpt:Option[String],countOpt:Option[Int])(implicitevidence$6:scredis.serialization.Reader[R]):scala.concurrent.Future[(Long,List[(String,R)])]"></a><a id="hScan[R](String,Long,Option[String],Option[Int])(Reader[R]):Future[(Long,List[(String,R)])]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#hScan[R](key:String,cursor:Long,matchOpt:Option[String],countOpt:Option[Int])(implicitevidence$6:scredis.serialization.Reader[R]):scala.concurrent.Future[(Long,List[(String,R)])]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">hScan</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="cursor">cursor: <a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a></span>, <span name="matchOpt">matchOpt: <a href="https://www.scala-lang.org/api/2.13.1/scala/Option.html#scala.Option" name="scala.Option" id="scala.Option" class="extype">Option</a>[<span name="scala.Predef.String" class="extype">String</span>] = <span class="symbol">None</span></span>, <span name="countOpt">countOpt: <a href="https://www.scala-lang.org/api/2.13.1/scala/Option.html#scala.Option" name="scala.Option" id="scala.Option" class="extype">Option</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a>] = <span class="symbol">None</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Reader.html" name="scredis.serialization.Reader" id="scredis.serialization.Reader" class="extype">Reader</a>[<span name="scredis.commands.HashCommands.hScan.R" class="extype">R</span>]</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[(<a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a>, <span name="scala.List" class="extype">List</span>[(<span name="scala.Predef.String" class="extype">String</span>, <span name="scredis.commands.HashCommands.hScan.R" class="extype">R</span>)])]</span></span><p class="shortcomment cmt">Incrementally iterates through the fields of a hash.</p><div class="fullcomment"><div class="comment cmt"><p>Incrementally iterates through the fields of a hash.
</p></div><dl class="paramcmts block"><dt class="param">cursor</dt><dd class="cmt"><p>the offset</p></dd><dt class="param">matchOpt</dt><dd class="cmt"><p>when defined, the command only returns elements matching the pattern</p></dd><dt class="param">countOpt</dt><dd class="cmt"><p>when defined, provides a hint of how many elements should be returned</p></dd><dt>returns</dt><dd class="cmt"><p>a pair containing the next cursor as its first element and the list of fields
(key-value pairs) as its second element</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/HashCommands.html" name="scredis.commands.HashCommands" id="scredis.commands.HashCommands" class="extype">HashCommands</a></dd><dt>Since</dt><dd><p>2.8.0</p></dd></dl></div></li><li class="indented0 " name="scredis.commands.HashCommands#hSet" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="hSet[W](key:String,field:String,value:W)(implicitevidence$7:scredis.serialization.Writer[W]):scala.concurrent.Future[Boolean]"></a><a id="hSet[W](String,String,W)(Writer[W]):Future[Boolean]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#hSet[W](key:String,field:String,value:W)(implicitevidence$7:scredis.serialization.Writer[W]):scala.concurrent.Future[Boolean]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">hSet</span><span class="tparams">[<span name="W">W</span>]</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="field">field: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="value">value: <span name="scredis.commands.HashCommands.hSet.W" class="extype">W</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Writer.html" name="scredis.serialization.Writer" id="scredis.serialization.Writer" class="extype">Writer</a>[<span name="scredis.commands.HashCommands.hSet.W" class="extype">W</span>]</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a>]</span></span><p class="shortcomment cmt">Sets the string value of a hash field.</p><div class="fullcomment"><div class="comment cmt"><p>Sets the string value of a hash field.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>hash key</p></dd><dt class="param">field</dt><dd class="cmt"><p>field name to set</p></dd><dt class="param">value</dt><dd class="cmt"><p>value to set</p></dd><dt>returns</dt><dd class="cmt"><p><b>true</b> if field is a new field in the hash and value was set, <b>false</b> if
field already exists and the value was updated</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/HashCommands.html" name="scredis.commands.HashCommands" id="scredis.commands.HashCommands" class="extype">HashCommands</a></dd><dt>Since</dt><dd><p>2.0.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if the value stored at key is not of type hash</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>If the field already exists in the hash, it is overwritten.</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.HashCommands#hSetNX" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="hSetNX[W](key:String,field:String,value:W)(implicitevidence$8:scredis.serialization.Writer[W]):scala.concurrent.Future[Boolean]"></a><a id="hSetNX[W](String,String,W)(Writer[W]):Future[Boolean]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#hSetNX[W](key:String,field:String,value:W)(implicitevidence$8:scredis.serialization.Writer[W]):scala.concurrent.Future[Boolean]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">hSetNX</span><span class="tparams">[<span name="W">W</span>]</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="field">field: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="value">value: <span name="scredis.commands.HashCommands.hSetNX.W" class="extype">W</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Writer.html" name="scredis.serialization.Writer" id="scredis.serialization.Writer" class="extype">Writer</a>[<span name="scredis.commands.HashCommands.hSetNX.W" class="extype">W</span>]</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a>]</span></span><p class="shortcomment cmt">Sets the value of a hash field, only if the field does not exist.</p><div class="fullcomment"><div class="comment cmt"><p>Sets the value of a hash field, only if the field does not exist.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>hash key</p></dd><dt class="param">field</dt><dd class="cmt"><p>field name to set</p></dd><dt class="param">value</dt><dd class="cmt"><p>value to set</p></dd><dt>returns</dt><dd class="cmt"><p><b>true</b> if field is a new field in the hash and value was set, <b>false</b> if
field already exists and no operation was performed</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/HashCommands.html" name="scredis.commands.HashCommands" id="scredis.commands.HashCommands" class="extype">HashCommands</a></dd><dt>Since</dt><dd><p>2.0.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if the value stored at key is not of type hash</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.HashCommands#hStrlen" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="hStrlen(key:String,field:String):scala.concurrent.Future[Long]"></a><a id="hStrlen(String,String):Future[Long]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#hStrlen(key:String,field:String):scala.concurrent.Future[Long]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">hStrlen</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="field">field: <span name="scala.Predef.String" class="extype">String</span></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a>]</span></span><p class="shortcomment cmt">Returns the length of the value associated with field in the hash stored at key.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the length of the value associated with field in the hash stored at key.
For numbers it is a count of their digits (+1 if number is negative)
For booleans it is true=4 and false=5
For strings it is number of bytes they occupy. ONLY if you don't use utf characters it will be their length.
If the key or the field do not exist, 0 is returned.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>hash key</p></dd><dt class="param">field</dt><dd class="cmt"><p>field name to set</p></dd><dt>returns</dt><dd class="cmt"><p>the string length of the value associated with field,
       or zero when field is not present in the hash or key does not exist at all.</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/HashCommands.html" name="scredis.commands.HashCommands" id="scredis.commands.HashCommands" class="extype">HashCommands</a></dd></dl></div></li><li class="indented0 " name="scredis.commands.HashCommands#hVals" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="hVals[R](key:String)(implicitevidence$9:scredis.serialization.Reader[R]):scala.concurrent.Future[List[R]]"></a><a id="hVals[R](String)(Reader[R]):Future[List[R]]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#hVals[R](key:String)(implicitevidence$9:scredis.serialization.Reader[R]):scala.concurrent.Future[List[R]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">hVals</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Reader.html" name="scredis.serialization.Reader" id="scredis.serialization.Reader" class="extype">Reader</a>[<span name="scredis.commands.HashCommands.hVals.R" class="extype">R</span>]</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="scala.List" class="extype">List</span>[<span name="scredis.commands.HashCommands.hVals.R" class="extype">R</span>]]</span></span><p class="shortcomment cmt">Returns all the values in a hash.</p><div class="fullcomment"><div class="comment cmt"><p>Returns all the values in a hash.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>hash key</p></dd><dt>returns</dt><dd class="cmt"><p>list of values, or the empty list if hash is empty or key does not exist</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/HashCommands.html" name="scredis.commands.HashCommands" id="scredis.commands.HashCommands" class="extype">HashCommands</a></dd><dt>Since</dt><dd><p>2.0.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if the value stored at key is not of type hash</p></span></dd></dl></div></li><li class="indented0 " name="scala.AnyRef#hashCode" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="hashCode():Int"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#hashCode():Int" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">hashCode</span><span class="params">()</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd><dt>Annotations</dt><dd><span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="scredis.commands.HashCommands#hmGet" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="hmGet[R](key:String,fields:String*)(implicitevidence$3:scredis.serialization.Reader[R]):scala.concurrent.Future[List[Option[R]]]"></a><a id="hmGet[R](String,String*)(Reader[R]):Future[List[Option[R]]]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#hmGet[R](key:String,fields:String*)(implicitevidence$3:scredis.serialization.Reader[R]):scala.concurrent.Future[List[Option[R]]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">hmGet</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="fields">fields: <span name="scala.Predef.String" class="extype">String</span>*</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Reader.html" name="scredis.serialization.Reader" id="scredis.serialization.Reader" class="extype">Reader</a>[<span name="scredis.commands.HashCommands.hmGet.R" class="extype">R</span>]</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="scala.List" class="extype">List</span>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Option.html#scala.Option" name="scala.Option" id="scala.Option" class="extype">Option</a>[<span name="scredis.commands.HashCommands.hmGet.R" class="extype">R</span>]]]</span></span><p class="shortcomment cmt">Returns the values associated to the specified hash fields.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the values associated to the specified hash fields.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>hash key</p></dd><dt class="param">fields</dt><dd class="cmt"><p>field(s) to retrieve</p></dd><dt>returns</dt><dd class="cmt"><p>list of value(s) associated to the specified field name(s)</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/HashCommands.html" name="scredis.commands.HashCommands" id="scredis.commands.HashCommands" class="extype">HashCommands</a></dd><dt>Since</dt><dd><p>2.0.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if the value stored at key is not of type hash</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>For every field that does not exist, <code>None</code> is returned.</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.HashCommands#hmGetAsMap" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="hmGetAsMap[R](key:String,fields:String*)(implicitevidence$4:scredis.serialization.Reader[R]):scala.concurrent.Future[Map[String,R]]"></a><a id="hmGetAsMap[R](String,String*)(Reader[R]):Future[Map[String,R]]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#hmGetAsMap[R](key:String,fields:String*)(implicitevidence$4:scredis.serialization.Reader[R]):scala.concurrent.Future[Map[String,R]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">hmGetAsMap</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="fields">fields: <span name="scala.Predef.String" class="extype">String</span>*</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Reader.html" name="scredis.serialization.Reader" id="scredis.serialization.Reader" class="extype">Reader</a>[<span name="scredis.commands.HashCommands.hmGetAsMap.R" class="extype">R</span>]</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="scala.Predef.Map" class="extype">Map</span>[<span name="scala.Predef.String" class="extype">String</span>, <span name="scredis.commands.HashCommands.hmGetAsMap.R" class="extype">R</span>]]</span></span><p class="shortcomment cmt">Returns a <code>Map</code> containing field-value pairs associated to the specified hash fields.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a <code>Map</code> containing field-value pairs associated to the specified hash fields.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>hash key</p></dd><dt class="param">fields</dt><dd class="cmt"><p>field(s) to retrieve</p></dd><dt>returns</dt><dd class="cmt"><p>field-value pairs associated to the specified field name(s)</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/HashCommands.html" name="scredis.commands.HashCommands" id="scredis.commands.HashCommands" class="extype">HashCommands</a></dd><dt>Since</dt><dd><p>2.0.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if the value stored at key is not of type hash</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>Every non-existent field gets removed from the resulting <code>Map</code>.</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.HashCommands#hmSet" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="hmSet[W](key:String,fieldValuePairs:Map[String,W])(implicitevidence$5:scredis.serialization.Writer[W]):scala.concurrent.Future[Unit]"></a><a id="hmSet[W](String,Map[String,W])(Writer[W]):Future[Unit]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#hmSet[W](key:String,fieldValuePairs:Map[String,W])(implicitevidence$5:scredis.serialization.Writer[W]):scala.concurrent.Future[Unit]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">hmSet</span><span class="tparams">[<span name="W">W</span>]</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="fieldValuePairs">fieldValuePairs: <span name="scala.Predef.Map" class="extype">Map</span>[<span name="scala.Predef.String" class="extype">String</span>, <span name="scredis.commands.HashCommands.hmSet.W" class="extype">W</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Writer.html" name="scredis.serialization.Writer" id="scredis.serialization.Writer" class="extype">Writer</a>[<span name="scredis.commands.HashCommands.hmSet.W" class="extype">W</span>]</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span></span><p class="shortcomment cmt">Sets multiple hash fields to multiple values.</p><div class="fullcomment"><div class="comment cmt"><p>Sets multiple hash fields to multiple values.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>hash key</p></dd><dt class="param">fieldValuePairs</dt><dd class="cmt"><p>field-value pair(s) to be set</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/HashCommands.html" name="scredis.commands.HashCommands" id="scredis.commands.HashCommands" class="extype">HashCommands</a></dd><dt>Since</dt><dd><p>2.0.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if the value stored at key is not of type hash</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>This command overwrites any existing fields in the hash. If key does not exist, a new
key holding a hash is created</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.StringCommands#incr" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="incr(key:String):scala.concurrent.Future[Long]"></a><a id="incr(String):Future[Long]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#incr(key:String):scala.concurrent.Future[Long]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">incr</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a>]</span></span><p class="shortcomment cmt">Increments the integer value of a key by one.</p><div class="fullcomment"><div class="comment cmt"><p>Increments the integer value of a key by one.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>the key to increment</p></dd><dt>returns</dt><dd class="cmt"><p>the value of key after the increment</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/StringCommands.html" name="scredis.commands.StringCommands" id="scredis.commands.StringCommands" class="extype">StringCommands</a></dd><dt>Since</dt><dd><p>1.0.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if the key contains a value of the wrong type or contains a string that cannot be
represented as integer</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>If the key does not exist, it is set to 0 before performing the operation.</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.StringCommands#incrBy" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="incrBy(key:String,increment:Long):scala.concurrent.Future[Long]"></a><a id="incrBy(String,Long):Future[Long]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#incrBy(key:String,increment:Long):scala.concurrent.Future[Long]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">incrBy</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="increment">increment: <a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a>]</span></span><p class="shortcomment cmt">Increments the integer value of a key by the given amount.</p><div class="fullcomment"><div class="comment cmt"><p>Increments the integer value of a key by the given amount.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>the key to increment</p></dd><dt class="param">increment</dt><dd class="cmt"><p>the increment</p></dd><dt>returns</dt><dd class="cmt"><p>the value of key after the decrement</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/StringCommands.html" name="scredis.commands.StringCommands" id="scredis.commands.StringCommands" class="extype">StringCommands</a></dd><dt>Since</dt><dd><p>1.0.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if the key contains a value of the wrong type or contains
a string that cannot be represented as integer</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>If the key does not exist, it is set to 0 before performing the operation.</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.StringCommands#incrByFloat" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="incrByFloat(key:String,increment:Double):scala.concurrent.Future[Double]"></a><a id="incrByFloat(String,Double):Future[Double]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#incrByFloat(key:String,increment:Double):scala.concurrent.Future[Double]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">incrByFloat</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="increment">increment: <a href="https://www.scala-lang.org/api/2.13.1/scala/Double.html#scala.Double" name="scala.Double" id="scala.Double" class="extype">Double</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Double.html#scala.Double" name="scala.Double" id="scala.Double" class="extype">Double</a>]</span></span><p class="shortcomment cmt">Increment the float value of a key by the given amount.</p><div class="fullcomment"><div class="comment cmt"><p>Increment the float value of a key by the given amount.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>the key to increment</p></dd><dt class="param">increment</dt><dd class="cmt"><p>the increment</p></dd><dt>returns</dt><dd class="cmt"><p>the value of key after the decrement</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/StringCommands.html" name="scredis.commands.StringCommands" id="scredis.commands.StringCommands" class="extype">StringCommands</a></dd><dt>Since</dt><dd><p>2.6.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if the key contains a value of the wrong type, the current key content or the
specified increment are not parseable as a double precision floating point number</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>If the key does not exist, it is set to 0 before performing the operation.</p></span></dd></dl></div></li><li class="indented0 " name="scala.Any#isInstanceOf" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="isInstanceOf[T0]:Boolean"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#isInstanceOf[T0]:Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">isInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>Any</dd></dl></div></li><li class="indented0 " name="scredis.commands.KeyCommands#keys" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="keys(pattern:String):scala.concurrent.Future[Set[String]]"></a><a id="keys(String):Future[Set[String]]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#keys(pattern:String):scala.concurrent.Future[Set[String]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">keys</span><span class="params">(<span name="pattern">pattern: <span name="scala.Predef.String" class="extype">String</span></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="scala.Predef.Set" class="extype">Set</span>[<span name="scala.Predef.String" class="extype">String</span>]]</span></span><p class="shortcomment cmt">Finds all keys matching the given pattern.</p><div class="fullcomment"><div class="comment cmt"><p>Finds all keys matching the given pattern.
</p></div><dl class="paramcmts block"><dt class="param">pattern</dt><dd class="cmt"><p>pattern to search for</p></dd><dt>returns</dt><dd class="cmt"><p>the matched keys, or the empty set if no keys match the given pattern</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/KeyCommands.html" name="scredis.commands.KeyCommands" id="scredis.commands.KeyCommands" class="extype">KeyCommands</a></dd><dt>Since</dt><dd><p>1.0.0</p></dd></dl></div></li><li class="indented0 " name="scredis.commands.ListCommands#lIndex" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="lIndex[R](key:String,index:Long)(implicitevidence$1:scredis.serialization.Reader[R]):scala.concurrent.Future[Option[R]]"></a><a id="lIndex[R](String,Long)(Reader[R]):Future[Option[R]]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#lIndex[R](key:String,index:Long)(implicitevidence$1:scredis.serialization.Reader[R]):scala.concurrent.Future[Option[R]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">lIndex</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="index">index: <a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Reader.html" name="scredis.serialization.Reader" id="scredis.serialization.Reader" class="extype">Reader</a>[<span name="scredis.commands.ListCommands.lIndex.R" class="extype">R</span>]</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Option.html#scala.Option" name="scala.Option" id="scala.Option" class="extype">Option</a>[<span name="scredis.commands.ListCommands.lIndex.R" class="extype">R</span>]]</span></span><p class="shortcomment cmt">Returns an element from a list by its index.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an element from a list by its index.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>list key</p></dd><dt class="param">index</dt><dd class="cmt"><p>zero-based position in the list</p></dd><dt>returns</dt><dd class="cmt"><p>the requested element, or <code>None</code> when index is out of range</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/ListCommands.html" name="scredis.commands.ListCommands" id="scredis.commands.ListCommands" class="extype">ListCommands</a></dd><dt>Since</dt><dd><p>1.0.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if key contains a non-list value</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>The index is zero-based, so 0 means the first element, 1 the second element and so on.
Negative indices can be used to designate elements starting at the tail of the list.
Here, -1 means the last element, -2 means the penultimate and so forth.</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.ListCommands#lInsert" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="lInsert[W1,W2](key:String,position:scredis.Position,pivot:W1,value:W2)(implicitevidence$2:scredis.serialization.Writer[W1],implicitevidence$3:scredis.serialization.Writer[W2]):scala.concurrent.Future[Option[Long]]"></a><a id="lInsert[W1,W2](String,Position,W1,W2)(Writer[W1],Writer[W2]):Future[Option[Long]]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#lInsert[W1,W2](key:String,position:scredis.Position,pivot:W1,value:W2)(implicitevidence$2:scredis.serialization.Writer[W1],implicitevidence$3:scredis.serialization.Writer[W2]):scala.concurrent.Future[Option[Long]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">lInsert</span><span class="tparams">[<span name="W1">W1</span>, <span name="W2">W2</span>]</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="position">position: <a href="package$$Position.html" name="scredis.Position" id="scredis.Position" class="extype">Position</a></span>, <span name="pivot">pivot: <span name="scredis.commands.ListCommands.lInsert.W1" class="extype">W1</span></span>, <span name="value">value: <span name="scredis.commands.ListCommands.lInsert.W2" class="extype">W2</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Writer.html" name="scredis.serialization.Writer" id="scredis.serialization.Writer" class="extype">Writer</a>[<span name="scredis.commands.ListCommands.lInsert.W1" class="extype">W1</span>]</span>, <span name="arg1">arg1: <a href="serialization/Writer.html" name="scredis.serialization.Writer" id="scredis.serialization.Writer" class="extype">Writer</a>[<span name="scredis.commands.ListCommands.lInsert.W2" class="extype">W2</span>]</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Option.html#scala.Option" name="scala.Option" id="scala.Option" class="extype">Option</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a>]]</span></span><p class="shortcomment cmt">Inserts an element before or after another element in a list.</p><div class="fullcomment"><div class="comment cmt"><p>Inserts an element before or after another element in a list.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>list key</p></dd><dt class="param">position</dt><dd class="cmt"><p>tell if a new value should be placed after of before pivot</p></dd><dt class="param">pivot</dt><dd class="cmt"><p>value after/before which the element should be inserted</p></dd><dt class="param">value</dt><dd class="cmt"><p>element to be inserted</p></dd><dt>returns</dt><dd class="cmt"><p>the length of the list after the insert operation, or None if the index is out of range</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/ListCommands.html" name="scredis.commands.ListCommands" id="scredis.commands.ListCommands" class="extype">ListCommands</a></dd><dt>Since</dt><dd><p>2.2.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if key contains a non-list value</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.ListCommands#lLen" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="lLen(key:String):scala.concurrent.Future[Long]"></a><a id="lLen(String):Future[Long]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#lLen(key:String):scala.concurrent.Future[Long]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">lLen</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a>]</span></span><p class="shortcomment cmt">Returns the length of a list.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the length of a list.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>list key</p></dd><dt>returns</dt><dd class="cmt"><p>the length of the list at key, or 0 if the key does not exist</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/ListCommands.html" name="scredis.commands.ListCommands" id="scredis.commands.ListCommands" class="extype">ListCommands</a></dd><dt>Since</dt><dd><p>1.0.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if key contains a non-list value</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.ListCommands#lPop" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="lPop[R](key:String)(implicitevidence$4:scredis.serialization.Reader[R]):scala.concurrent.Future[Option[R]]"></a><a id="lPop[R](String)(Reader[R]):Future[Option[R]]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#lPop[R](key:String)(implicitevidence$4:scredis.serialization.Reader[R]):scala.concurrent.Future[Option[R]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">lPop</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Reader.html" name="scredis.serialization.Reader" id="scredis.serialization.Reader" class="extype">Reader</a>[<span name="scredis.commands.ListCommands.lPop.R" class="extype">R</span>]</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Option.html#scala.Option" name="scala.Option" id="scala.Option" class="extype">Option</a>[<span name="scredis.commands.ListCommands.lPop.R" class="extype">R</span>]]</span></span><p class="shortcomment cmt">Removes and returns the first element of a list.</p><div class="fullcomment"><div class="comment cmt"><p>Removes and returns the first element of a list.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>list key</p></dd><dt>returns</dt><dd class="cmt"><p>the popped element, or <code>None</code> if the key does not exist</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/ListCommands.html" name="scredis.commands.ListCommands" id="scredis.commands.ListCommands" class="extype">ListCommands</a></dd><dt>Since</dt><dd><p>1.0.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if key contains a non-list value</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.ListCommands#lPush" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="lPush[W](key:String,values:W*)(implicitevidence$5:scredis.serialization.Writer[W]):scala.concurrent.Future[Long]"></a><a id="lPush[W](String,W*)(Writer[W]):Future[Long]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#lPush[W](key:String,values:W*)(implicitevidence$5:scredis.serialization.Writer[W]):scala.concurrent.Future[Long]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">lPush</span><span class="tparams">[<span name="W">W</span>]</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="values">values: <span name="scredis.commands.ListCommands.lPush.W" class="extype">W</span>*</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Writer.html" name="scredis.serialization.Writer" id="scredis.serialization.Writer" class="extype">Writer</a>[<span name="scredis.commands.ListCommands.lPush.W" class="extype">W</span>]</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a>]</span></span><p class="shortcomment cmt">Prepends one or multiple values to a list.</p><div class="fullcomment"><div class="comment cmt"><p>Prepends one or multiple values to a list.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>list key</p></dd><dt class="param">values</dt><dd class="cmt"><p>value(s) to prepend</p></dd><dt>returns</dt><dd class="cmt"><p>the length of the list after the push operations</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/ListCommands.html" name="scredis.commands.ListCommands" id="scredis.commands.ListCommands" class="extype">ListCommands</a></dd><dt>Since</dt><dd><p>1.0.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if key contains a non-list value</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>If key does not exist, it is created as empty list before performing the push operation.
Redis versions older than 2.4 can only push one value per call.</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.ListCommands#lPushX" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="lPushX[W](key:String,value:W)(implicitevidence$6:scredis.serialization.Writer[W]):scala.concurrent.Future[Long]"></a><a id="lPushX[W](String,W)(Writer[W]):Future[Long]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#lPushX[W](key:String,value:W)(implicitevidence$6:scredis.serialization.Writer[W]):scala.concurrent.Future[Long]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">lPushX</span><span class="tparams">[<span name="W">W</span>]</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="value">value: <span name="scredis.commands.ListCommands.lPushX.W" class="extype">W</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Writer.html" name="scredis.serialization.Writer" id="scredis.serialization.Writer" class="extype">Writer</a>[<span name="scredis.commands.ListCommands.lPushX.W" class="extype">W</span>]</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a>]</span></span><p class="shortcomment cmt">Prepends a value to a list, only if the list exists.</p><div class="fullcomment"><div class="comment cmt"><p>Prepends a value to a list, only if the list exists.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>list key</p></dd><dt class="param">value</dt><dd class="cmt"><p>value to prepend</p></dd><dt>returns</dt><dd class="cmt"><p>the length of the list after the push operation</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/ListCommands.html" name="scredis.commands.ListCommands" id="scredis.commands.ListCommands" class="extype">ListCommands</a></dd><dt>Since</dt><dd><p>2.2.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if key contains a non-list value</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.ListCommands#lRange" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="lRange[R](key:String,start:Long,stop:Long)(implicitevidence$7:scredis.serialization.Reader[R]):scala.concurrent.Future[List[R]]"></a><a id="lRange[R](String,Long,Long)(Reader[R]):Future[List[R]]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#lRange[R](key:String,start:Long,stop:Long)(implicitevidence$7:scredis.serialization.Reader[R]):scala.concurrent.Future[List[R]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">lRange</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="start">start: <a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a> = <span class="symbol">0</span></span>, <span name="stop">stop: <a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a> = <span class="symbol">-1</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Reader.html" name="scredis.serialization.Reader" id="scredis.serialization.Reader" class="extype">Reader</a>[<span name="scredis.commands.ListCommands.lRange.R" class="extype">R</span>]</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="scala.List" class="extype">List</span>[<span name="scredis.commands.ListCommands.lRange.R" class="extype">R</span>]]</span></span><p class="shortcomment cmt">Returns a range of elements from a list.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a range of elements from a list.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>list key</p></dd><dt class="param">start</dt><dd class="cmt"><p>start offset (inclusive)</p></dd><dt class="param">stop</dt><dd class="cmt"><p>stop offset (inclusive)</p></dd><dt>returns</dt><dd class="cmt"><p>list of elements in the specified range, or the empty list if there are no such
elements or the key does not exist</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/ListCommands.html" name="scredis.commands.ListCommands" id="scredis.commands.ListCommands" class="extype">ListCommands</a></dd><dt>Since</dt><dd><p>1.0.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if key contains a non-list value</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>The offsets start and end are zero-based indexes, with 0 being the first element of the
list (the head of the list), 1 being the next element and so on. These offsets can also be
negative numbers indicating offsets starting at the end of the list. For example, -1 is the
last element of the list, -2 the penultimate, and so on. Both offsets are inclusive, i.e.
LRANGE key 0 10 will return 11 elements (if they exist).</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.ListCommands#lRem" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="lRem[W](key:String,value:W,count:Int)(implicitevidence$8:scredis.serialization.Writer[W]):scala.concurrent.Future[Long]"></a><a id="lRem[W](String,W,Int)(Writer[W]):Future[Long]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#lRem[W](key:String,value:W,count:Int)(implicitevidence$8:scredis.serialization.Writer[W]):scala.concurrent.Future[Long]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">lRem</span><span class="tparams">[<span name="W">W</span>]</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="value">value: <span name="scredis.commands.ListCommands.lRem.W" class="extype">W</span></span>, <span name="count">count: <a href="https://www.scala-lang.org/api/2.13.1/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a> = <span class="symbol">0</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Writer.html" name="scredis.serialization.Writer" id="scredis.serialization.Writer" class="extype">Writer</a>[<span name="scredis.commands.ListCommands.lRem.W" class="extype">W</span>]</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a>]</span></span><p class="shortcomment cmt">Removes the first count occurrences of elements equal to value from the list stored at key.</p><div class="fullcomment"><div class="comment cmt"><p>Removes the first count occurrences of elements equal to value from the list stored at key.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>list key</p></dd><dt class="param">value</dt><dd class="cmt"><p>value to be removed from the list</p></dd><dt class="param">count</dt><dd class="cmt"><p>indicates the number of found values that should be removed, see above note</p></dd><dt>returns</dt><dd class="cmt"><p>the number of removed elements</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/ListCommands.html" name="scredis.commands.ListCommands" id="scredis.commands.ListCommands" class="extype">ListCommands</a></dd><dt>Since</dt><dd><p>1.0.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if key contains a non-list value</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>The count argument influences the operation in the following ways:</p><pre>count &gt; <span class="num">0</span>: Remove elements equal to value moving from head to tail.
count &lt; <span class="num">0</span>: Remove elements equal to value moving from tail to head.
count = <span class="num">0</span>: Remove all elements equal to value.</pre></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.ListCommands#lSet" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="lSet[W](key:String,index:Long,value:W)(implicitevidence$9:scredis.serialization.Writer[W]):scala.concurrent.Future[Unit]"></a><a id="lSet[W](String,Long,W)(Writer[W]):Future[Unit]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#lSet[W](key:String,index:Long,value:W)(implicitevidence$9:scredis.serialization.Writer[W]):scala.concurrent.Future[Unit]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">lSet</span><span class="tparams">[<span name="W">W</span>]</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="index">index: <a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a></span>, <span name="value">value: <span name="scredis.commands.ListCommands.lSet.W" class="extype">W</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Writer.html" name="scredis.serialization.Writer" id="scredis.serialization.Writer" class="extype">Writer</a>[<span name="scredis.commands.ListCommands.lSet.W" class="extype">W</span>]</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span></span><p class="shortcomment cmt">Sets the value of an element in a list by its index.</p><div class="fullcomment"><div class="comment cmt"><p>Sets the value of an element in a list by its index.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>list key</p></dd><dt class="param">index</dt><dd class="cmt"><p>position of the element to set</p></dd><dt class="param">value</dt><dd class="cmt"><p>value to be set at index</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/ListCommands.html" name="scredis.commands.ListCommands" id="scredis.commands.ListCommands" class="extype">ListCommands</a></dd><dt>Since</dt><dd><p>1.0.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if index is out of range or if key contains a non-list value</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.ListCommands#lTrim" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="lTrim(key:String,start:Long,stop:Long):scala.concurrent.Future[Unit]"></a><a id="lTrim(String,Long,Long):Future[Unit]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#lTrim(key:String,start:Long,stop:Long):scala.concurrent.Future[Unit]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">lTrim</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="start">start: <a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a></span>, <span name="stop">stop: <a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span></span><p class="shortcomment cmt">Trims a list to the specified range.</p><div class="fullcomment"><div class="comment cmt"><p>Trims a list to the specified range.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>list key</p></dd><dt class="param">start</dt><dd class="cmt"><p>start offset (inclusive)</p></dd><dt class="param">stop</dt><dd class="cmt"><p>stop offset (inclusive)</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/ListCommands.html" name="scredis.commands.ListCommands" id="scredis.commands.ListCommands" class="extype">ListCommands</a></dd><dt>Since</dt><dd><p>1.0.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if key contains a non-list value</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>Out of range indexes will not produce an error: if start is larger than the end of the
list, or start &gt; end, the result will be an empty list (which causes key to be removed). If
end is larger than the end of the list, Redis will treat it like the last element of the list.</p></span></dd></dl></div></li><li class="indented0 " name="com.typesafe.scalalogging.LazyLogging#logger" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="logger:com.typesafe.scalalogging.Logger"></a><a id="logger:Logger"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#logger:com.typesafe.scalalogging.Logger" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">lazy val</span></span> <span class="symbol"><span class="name">logger</span><span class="result">: <span name="com.typesafe.scalalogging.Logger" class="extype">Logger</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd>LazyLogging</dd><dt>Annotations</dt><dd><span class="name">@transient</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="scredis.commands.StringCommands#mGet" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="mGet[R](keys:String*)(implicitevidence$6:scredis.serialization.Reader[R]):scala.concurrent.Future[List[Option[R]]]"></a><a id="mGet[R](String*)(Reader[R]):Future[List[Option[R]]]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#mGet[R](keys:String*)(implicitevidence$6:scredis.serialization.Reader[R]):scala.concurrent.Future[List[Option[R]]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">mGet</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="keys">keys: <span name="scala.Predef.String" class="extype">String</span>*</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Reader.html" name="scredis.serialization.Reader" id="scredis.serialization.Reader" class="extype">Reader</a>[<span name="scredis.commands.StringCommands.mGet.R" class="extype">R</span>]</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="scala.List" class="extype">List</span>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Option.html#scala.Option" name="scala.Option" id="scala.Option" class="extype">Option</a>[<span name="scredis.commands.StringCommands.mGet.R" class="extype">R</span>]]]</span></span><p class="shortcomment cmt">Returns the values of all specified keys.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the values of all specified keys.
</p></div><dl class="paramcmts block"><dt class="param">keys</dt><dd class="cmt"><p>the keys to fetch</p></dd><dt>returns</dt><dd class="cmt"><p>list of value(s) stored at the specified key(s)</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/StringCommands.html" name="scredis.commands.StringCommands" id="scredis.commands.StringCommands" class="extype">StringCommands</a></dd><dt>Since</dt><dd><p>1.0.0</p></dd><dt>Note</dt><dd><span class="cmt"><p>For every key that does not hold a string value or does not exist, <code>None</code> is returned.
Because of this, the operation never fails.</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.StringCommands#mGetAsMap" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="mGetAsMap[R](keys:String*)(implicitevidence$7:scredis.serialization.Reader[R]):scala.concurrent.Future[Map[String,R]]"></a><a id="mGetAsMap[R](String*)(Reader[R]):Future[Map[String,R]]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#mGetAsMap[R](keys:String*)(implicitevidence$7:scredis.serialization.Reader[R]):scala.concurrent.Future[Map[String,R]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">mGetAsMap</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="keys">keys: <span name="scala.Predef.String" class="extype">String</span>*</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Reader.html" name="scredis.serialization.Reader" id="scredis.serialization.Reader" class="extype">Reader</a>[<span name="scredis.commands.StringCommands.mGetAsMap.R" class="extype">R</span>]</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="scala.Predef.Map" class="extype">Map</span>[<span name="scala.Predef.String" class="extype">String</span>, <span name="scredis.commands.StringCommands.mGetAsMap.R" class="extype">R</span>]]</span></span><p class="shortcomment cmt">Returns a <code>Map</code> containing the specified key(s) paired to their respective value(s).</p><div class="fullcomment"><div class="comment cmt"><p>Returns a <code>Map</code> containing the specified key(s) paired to their respective value(s).
</p></div><dl class="paramcmts block"><dt class="param">keys</dt><dd class="cmt"><p>the keys to fetch</p></dd><dt>returns</dt><dd class="cmt"><p>map of key-value pairs</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/StringCommands.html" name="scredis.commands.StringCommands" id="scredis.commands.StringCommands" class="extype">StringCommands</a></dd><dt>Since</dt><dd><p>1.0.0</p></dd><dt>Note</dt><dd><span class="cmt"><p>Every key that does not hold a string value or does not exist will be removed from the
resulting <code>Map</code>.</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.StringCommands#mSet" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="mSet[W](keyValuePairs:Map[String,W])(implicitevidence$8:scredis.serialization.Writer[W]):scala.concurrent.Future[Unit]"></a><a id="mSet[W](Map[String,W])(Writer[W]):Future[Unit]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#mSet[W](keyValuePairs:Map[String,W])(implicitevidence$8:scredis.serialization.Writer[W]):scala.concurrent.Future[Unit]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">mSet</span><span class="tparams">[<span name="W">W</span>]</span><span class="params">(<span name="keyValuePairs">keyValuePairs: <span name="scala.Predef.Map" class="extype">Map</span>[<span name="scala.Predef.String" class="extype">String</span>, <span name="scredis.commands.StringCommands.mSet.W" class="extype">W</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Writer.html" name="scredis.serialization.Writer" id="scredis.serialization.Writer" class="extype">Writer</a>[<span name="scredis.commands.StringCommands.mSet.W" class="extype">W</span>]</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span></span><p class="shortcomment cmt">Atomically sets multiple keys to multiple values.</p><div class="fullcomment"><div class="comment cmt"><p>Atomically sets multiple keys to multiple values.
</p></div><dl class="paramcmts block"><dt class="param">keyValuePairs</dt><dd class="cmt"><p>map of key-value pairs to set</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/StringCommands.html" name="scredis.commands.StringCommands" id="scredis.commands.StringCommands" class="extype">StringCommands</a></dd><dt>Since</dt><dd><p>1.0.1</p></dd><dt>Note</dt><dd><span class="cmt"><p>MSET replaces existing values with new values, just as regular SET.</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.StringCommands#mSetNX" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="mSetNX[W](keyValuePairs:Map[String,W])(implicitevidence$9:scredis.serialization.Writer[W]):scala.concurrent.Future[Boolean]"></a><a id="mSetNX[W](Map[String,W])(Writer[W]):Future[Boolean]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#mSetNX[W](keyValuePairs:Map[String,W])(implicitevidence$9:scredis.serialization.Writer[W]):scala.concurrent.Future[Boolean]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">mSetNX</span><span class="tparams">[<span name="W">W</span>]</span><span class="params">(<span name="keyValuePairs">keyValuePairs: <span name="scala.Predef.Map" class="extype">Map</span>[<span name="scala.Predef.String" class="extype">String</span>, <span name="scredis.commands.StringCommands.mSetNX.W" class="extype">W</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Writer.html" name="scredis.serialization.Writer" id="scredis.serialization.Writer" class="extype">Writer</a>[<span name="scredis.commands.StringCommands.mSetNX.W" class="extype">W</span>]</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a>]</span></span><p class="shortcomment cmt">Atomically sets multiple keys to multiple values, only if none of the keys exist.</p><div class="fullcomment"><div class="comment cmt"><p>Atomically sets multiple keys to multiple values, only if none of the keys exist.
</p></div><dl class="paramcmts block"><dt class="param">keyValuePairs</dt><dd class="cmt"><p>map of key-value pairs to set</p></dd><dt>returns</dt><dd class="cmt"><p><b>true</b> if all the keys were set, <b>false</b> if at least one key already existed and thus
no operation was performed.</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/StringCommands.html" name="scredis.commands.StringCommands" id="scredis.commands.StringCommands" class="extype">StringCommands</a></dd><dt>Since</dt><dd><p>1.0.1</p></dd><dt>Note</dt><dd><span class="cmt"><p>MSETNX will not perform any operation at all even if just a single key already exists.</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.KeyCommands#migrate" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="migrate(key:String,host:String,port:Int,database:Int,timeout:scala.concurrent.duration.FiniteDuration,copy:Boolean,replace:Boolean):scala.concurrent.Future[Unit]"></a><a id="migrate(String,String,Int,Int,FiniteDuration,Boolean,Boolean):Future[Unit]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#migrate(key:String,host:String,port:Int,database:Int,timeout:scala.concurrent.duration.FiniteDuration,copy:Boolean,replace:Boolean):scala.concurrent.Future[Unit]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">migrate</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="host">host: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="port">port: <a href="https://www.scala-lang.org/api/2.13.1/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a> = <span class="symbol">6379</span></span>, <span name="database">database: <a href="https://www.scala-lang.org/api/2.13.1/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a> = <span class="symbol">0</span></span>, <span name="timeout">timeout: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/duration/FiniteDuration.html#scala.concurrent.duration.FiniteDuration" name="scala.concurrent.duration.FiniteDuration" id="scala.concurrent.duration.FiniteDuration" class="extype">FiniteDuration</a> = <span class="symbol">2 seconds</span></span>, <span name="copy">copy: <a href="https://www.scala-lang.org/api/2.13.1/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a> = <span class="symbol">false</span></span>, <span name="replace">replace: <a href="https://www.scala-lang.org/api/2.13.1/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a> = <span class="symbol">false</span></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span></span><p class="shortcomment cmt">Atomically transfers a key from a Redis instance to another one.</p><div class="fullcomment"><div class="comment cmt"><p>Atomically transfers a key from a Redis instance to another one.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>key to transfer</p></dd><dt class="param">host</dt><dd class="cmt"><p>destination host</p></dd><dt class="param">port</dt><dd class="cmt"><p>destination port</p></dd><dt class="param">database</dt><dd class="cmt"><p>destination database</p></dd><dt class="param">timeout</dt><dd class="cmt"><p>timeout duration, up to milliseconds precision</p></dd><dt class="param">copy</dt><dd class="cmt"><p>if <b>true</b>, do not remove the key from the local instance</p></dd><dt class="param">replace</dt><dd class="cmt"><p>if <b>true</b>, replace existing key on the remote instance</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/KeyCommands.html" name="scredis.commands.KeyCommands" id="scredis.commands.KeyCommands" class="extype">KeyCommands</a></dd><dt>Since</dt><dd><p>2.6.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if an error occurs</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.KeyCommands#move" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="move(key:String,database:Int):scala.concurrent.Future[Boolean]"></a><a id="move(String,Int):Future[Boolean]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#move(key:String,database:Int):scala.concurrent.Future[Boolean]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">move</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="database">database: <a href="https://www.scala-lang.org/api/2.13.1/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a>]</span></span><p class="shortcomment cmt">Moves a key to another database.</p><div class="fullcomment"><div class="comment cmt"><p>Moves a key to another database.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>key to move</p></dd><dt class="param">database</dt><dd class="cmt"><p>destination database</p></dd><dt>returns</dt><dd class="cmt"><p>true if key was moved, false otherwise</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/KeyCommands.html" name="scredis.commands.KeyCommands" id="scredis.commands.KeyCommands" class="extype">KeyCommands</a></dd><dt>Since</dt><dd><p>1.0.0</p></dd></dl></div></li><li class="indented0 " name="scala.AnyRef#ne" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="ne(x$1:AnyRef):Boolean"></a><a id="ne(AnyRef):Boolean"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#ne(x$1:AnyRef):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">ne</span><span class="params">(<span name="arg0">arg0: <a href="https://www.scala-lang.org/api/2.13.1/scala/AnyRef.html#scala.AnyRef" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div></li><li class="indented0 " name="scala.AnyRef#notify" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="notify():Unit"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#notify():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">notify</span><span class="params">()</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#notifyAll" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="notifyAll():Unit"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#notifyAll():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">notifyAll</span><span class="params">()</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="scredis.commands.KeyCommands#objectEncoding" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="objectEncoding(key:String):scala.concurrent.Future[Option[String]]"></a><a id="objectEncoding(String):Future[Option[String]]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#objectEncoding(key:String):scala.concurrent.Future[Option[String]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">objectEncoding</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Option.html#scala.Option" name="scala.Option" id="scala.Option" class="extype">Option</a>[<span name="scala.Predef.String" class="extype">String</span>]]</span></span><p class="shortcomment cmt">Returns the kind of internal representation used in order to store the value associated with
a key.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the kind of internal representation used in order to store the value associated with
a key.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>the key</p></dd><dt>returns</dt><dd class="cmt"><p>the object encoding or <code>None</code> if the key does not exist</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/KeyCommands.html" name="scredis.commands.KeyCommands" id="scredis.commands.KeyCommands" class="extype">KeyCommands</a></dd><dt>Since</dt><dd><p>2.2.3</p></dd><dt>Note</dt><dd><span class="cmt"><p>Objects can be encoded in different ways:
Strings can be encoded as <code>raw</code> or <code>int</code>
Lists can be encoded as <code>ziplist</code> or <code>linkedlist</code>
Sets can be encoded as <code>intset</code> or <code>hashtable</code>
Hashes can be encoded as <code>zipmap</code> or <code>hashtable</code>
SortedSets can be encoded as <code>ziplist</code> or <code>skiplist</code></p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.KeyCommands#objectIdleTime" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="objectIdleTime(key:String):scala.concurrent.Future[Option[Long]]"></a><a id="objectIdleTime(String):Future[Option[Long]]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#objectIdleTime(key:String):scala.concurrent.Future[Option[Long]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">objectIdleTime</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Option.html#scala.Option" name="scala.Option" id="scala.Option" class="extype">Option</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a>]]</span></span><p class="shortcomment cmt">Returns the number of seconds since the object stored at the specified key is idle (not
requested by read or write operations).</p><div class="fullcomment"><div class="comment cmt"><p>Returns the number of seconds since the object stored at the specified key is idle (not
requested by read or write operations).
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>the key</p></dd><dt>returns</dt><dd class="cmt"><p>the number of seconds since the object is idle or <code>None</code> if the key does not exist</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/KeyCommands.html" name="scredis.commands.KeyCommands" id="scredis.commands.KeyCommands" class="extype">KeyCommands</a></dd><dt>Since</dt><dd><p>2.2.3</p></dd><dt>Note</dt><dd><span class="cmt"><p>While the value is returned in seconds the actual resolution of this timer is
10 seconds, but may vary in future implementations.</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.KeyCommands#objectRefCount" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="objectRefCount(key:String):scala.concurrent.Future[Option[Long]]"></a><a id="objectRefCount(String):Future[Option[Long]]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#objectRefCount(key:String):scala.concurrent.Future[Option[Long]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">objectRefCount</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Option.html#scala.Option" name="scala.Option" id="scala.Option" class="extype">Option</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a>]]</span></span><p class="shortcomment cmt">Returns the number of references of the value associated with the specified key.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the number of references of the value associated with the specified key.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>the key</p></dd><dt>returns</dt><dd class="cmt"><p>the number of references or <code>None</code> if the key does not exist</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/KeyCommands.html" name="scredis.commands.KeyCommands" id="scredis.commands.KeyCommands" class="extype">KeyCommands</a></dd><dt>Since</dt><dd><p>2.2.3</p></dd></dl></div></li><li class="indented0 " name="scredis.commands.KeyCommands#pExpire" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="pExpire(key:String,ttlMillis:Long):scala.concurrent.Future[Boolean]"></a><a id="pExpire(String,Long):Future[Boolean]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#pExpire(key:String,ttlMillis:Long):scala.concurrent.Future[Boolean]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">pExpire</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="ttlMillis">ttlMillis: <a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a>]</span></span><p class="shortcomment cmt">Sets a key's time to live in milliseconds.</p><div class="fullcomment"><div class="comment cmt"><p>Sets a key's time to live in milliseconds.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>key to expire</p></dd><dt class="param">ttlMillis</dt><dd class="cmt"><p>time-to-live in milliseconds</p></dd><dt>returns</dt><dd class="cmt"><p><b>true</b> if the ttl was set, <b>false</b> if key does not exist or
the timeout could not be set</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/KeyCommands.html" name="scredis.commands.KeyCommands" id="scredis.commands.KeyCommands" class="extype">KeyCommands</a></dd><dt>Since</dt><dd><p>2.6.0</p></dd></dl></div></li><li class="indented0 " name="scredis.commands.KeyCommands#pExpireAt" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="pExpireAt(key:String,timestampMillis:Long):scala.concurrent.Future[Boolean]"></a><a id="pExpireAt(String,Long):Future[Boolean]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#pExpireAt(key:String,timestampMillis:Long):scala.concurrent.Future[Boolean]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">pExpireAt</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="timestampMillis">timestampMillis: <a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a>]</span></span><p class="shortcomment cmt">Sets the expiration for a key as a UNIX timestamp specified in milliseconds.</p><div class="fullcomment"><div class="comment cmt"><p>Sets the expiration for a key as a UNIX timestamp specified in milliseconds.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>key to expire</p></dd><dt class="param">timestampMillis</dt><dd class="cmt"><p>UNIX milliseconds-timestamp at which the key should expire</p></dd><dt>returns</dt><dd class="cmt"><p><b>true</b> if the ttl was set, <b>false</b> if key does not exist or
the timeout could not be set</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/KeyCommands.html" name="scredis.commands.KeyCommands" id="scredis.commands.KeyCommands" class="extype">KeyCommands</a></dd><dt>Since</dt><dd><p>2.6.0</p></dd></dl></div></li><li class="indented0 " name="scredis.commands.StringCommands#pSetEX" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="pSetEX[W](key:String,value:W,ttlMillis:Long)(implicitevidence$10:scredis.serialization.Writer[W]):scala.concurrent.Future[Unit]"></a><a id="pSetEX[W](String,W,Long)(Writer[W]):Future[Unit]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#pSetEX[W](key:String,value:W,ttlMillis:Long)(implicitevidence$10:scredis.serialization.Writer[W]):scala.concurrent.Future[Unit]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">pSetEX</span><span class="tparams">[<span name="W">W</span>]</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="value">value: <span name="scredis.commands.StringCommands.pSetEX.W" class="extype">W</span></span>, <span name="ttlMillis">ttlMillis: <a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Writer.html" name="scredis.serialization.Writer" id="scredis.serialization.Writer" class="extype">Writer</a>[<span name="scredis.commands.StringCommands.pSetEX.W" class="extype">W</span>]</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span></span><p class="shortcomment cmt">Sets the value and expiration in milliseconds of a key.</p><div class="fullcomment"><div class="comment cmt"><p>Sets the value and expiration in milliseconds of a key.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>target key to set</p></dd><dt class="param">value</dt><dd class="cmt"><p>value to be stored at key</p></dd><dt class="param">ttlMillis</dt><dd class="cmt"><p>time-to-live in milliseconds</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/StringCommands.html" name="scredis.commands.StringCommands" id="scredis.commands.StringCommands" class="extype">StringCommands</a></dd><dt>Since</dt><dd><p>2.6.0</p></dd><dt>Note</dt><dd><span class="cmt"><p>If key already holds a value, it is overwritten, regardless of its type.</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.KeyCommands#pTtl" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="pTtl(key:String):scala.concurrent.Future[Either[Boolean,Long]]"></a><a id="pTtl(String):Future[Either[Boolean,Long]]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#pTtl(key:String):scala.concurrent.Future[Either[Boolean,Long]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">pTtl</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="scala.Either" class="extype">Either</span>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a>, <a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a>]]</span></span><p class="shortcomment cmt">Gets the time to live for a key in milliseconds.</p><div class="fullcomment"><div class="comment cmt"><p>Gets the time to live for a key in milliseconds.</p><pre>result <span class="kw">match</span> {
  <span class="kw">case</span> Left(<span class="kw">false</span>) <span class="kw">=&gt;</span> <span class="cmt">// key does not exist</span>
  <span class="kw">case</span> Left(<span class="kw">true</span>) <span class="kw">=&gt;</span> <span class="cmt">// key exists but has no associated expire</span>
  <span class="kw">case</span> Right(ttl) <span class="kw">=&gt;</span>
}</pre></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>the target key</p></dd><dt>returns</dt><dd class="cmt"><p><code>Right(ttl)</code> where ttl is the time-to-live in milliseconds for specified key,
<code>Left(false)</code> if key does not exist or <code>Left(true)</code> if key exists but has no associated
expire</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/KeyCommands.html" name="scredis.commands.KeyCommands" id="scredis.commands.KeyCommands" class="extype">KeyCommands</a></dd><dt>Since</dt><dd><p>2.6.0</p></dd><dt>Note</dt><dd><span class="cmt"><p>For <code>Redis</code> version &lt;= 2.8.x, <code>Left(false)</code> will be returned when the key does not
exists and when it exists but has no associated expire (<code>Redis</code> returns the same error code
for both cases). In other words, you can simply check the following</p><pre>result <span class="kw">match</span> {
  <span class="kw">case</span> Left(_) <span class="kw">=&gt;</span>
  <span class="kw">case</span> Right(ttl) <span class="kw">=&gt;</span>
}</pre></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.KeyCommands#persist" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="persist(key:String):scala.concurrent.Future[Boolean]"></a><a id="persist(String):Future[Boolean]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#persist(key:String):scala.concurrent.Future[Boolean]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">persist</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a>]</span></span><p class="shortcomment cmt">Removes the expiration from a key.</p><div class="fullcomment"><div class="comment cmt"><p>Removes the expiration from a key.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>key to persist</p></dd><dt>returns</dt><dd class="cmt"><p><b>true</b> if key was persisted, <b>false</b> if key does not exist or does not have an
associated timeout</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/KeyCommands.html" name="scredis.commands.KeyCommands" id="scredis.commands.KeyCommands" class="extype">KeyCommands</a></dd><dt>Since</dt><dd><p>2.2.0</p></dd></dl></div></li><li class="indented0 " name="scredis.commands.HyperLogLogCommands#pfAdd" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="pfAdd[W](key:String,elements:W*)(implicitevidence$1:scredis.serialization.Writer[W]):scala.concurrent.Future[Boolean]"></a><a id="pfAdd[W](String,W*)(Writer[W]):Future[Boolean]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#pfAdd[W](key:String,elements:W*)(implicitevidence$1:scredis.serialization.Writer[W]):scala.concurrent.Future[Boolean]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">pfAdd</span><span class="tparams">[<span name="W">W</span>]</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="elements">elements: <span name="scredis.commands.HyperLogLogCommands.pfAdd.W" class="extype">W</span>*</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Writer.html" name="scredis.serialization.Writer" id="scredis.serialization.Writer" class="extype">Writer</a>[<span name="scredis.commands.HyperLogLogCommands.pfAdd.W" class="extype">W</span>]</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a>]</span></span><p class="shortcomment cmt">Adds all the element arguments to the HyperLogLog data structure stored at specified key.</p><div class="fullcomment"><div class="comment cmt"><p>Adds all the element arguments to the HyperLogLog data structure stored at specified key.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>the key of the HyperLogLog data structure</p></dd><dt class="param">elements</dt><dd class="cmt"><p>element(s) to add to the HyperLogLog data structure</p></dd><dt>returns</dt><dd class="cmt"><p><b>true</b> if at least one HyperLogLog internal register was altered, <b>false</b> otherwise</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/HyperLogLogCommands.html" name="scredis.commands.HyperLogLogCommands" id="scredis.commands.HyperLogLogCommands" class="extype">HyperLogLogCommands</a></dd><dt>Since</dt><dd><p>2.8.9</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if key is not of HyperLogLog type</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>The HyperLogLog data structure can be used in order to count unique elements in a set
using just a small constant amount of memory, specifically 12k bytes for every HyperLogLog
(plus a few bytes for the key itself).
The returned cardinality of the observed set is not exact, but approximated with a standard
error of 0.81%.</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.HyperLogLogCommands#pfCount" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="pfCount(keys:String*):scala.concurrent.Future[Long]"></a><a id="pfCount(String*):Future[Long]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#pfCount(keys:String*):scala.concurrent.Future[Long]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">pfCount</span><span class="params">(<span name="keys">keys: <span name="scala.Predef.String" class="extype">String</span>*</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a>]</span></span><p class="shortcomment cmt">When called with a single key, returns the approximated cardinality computed by the
HyperLogLog data structure stored at the specified variable, which is 0 if the variable
does not exist.</p><div class="fullcomment"><div class="comment cmt"><p>When called with a single key, returns the approximated cardinality computed by the
HyperLogLog data structure stored at the specified variable, which is 0 if the variable
does not exist.</p><p>When called with multiple keys, returns the approximated cardinality of the union of the
HyperLogLogs passed, by internally merging the HyperLogLogs stored at the provided keys into
a temporary HyperLogLog.
</p></div><dl class="paramcmts block"><dt class="param">keys</dt><dd class="cmt"><p>key(s) of the HyperLogLog data structure to count</p></dd><dt>returns</dt><dd class="cmt"><p>the approximate number of unique elements observed via PFADD</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/HyperLogLogCommands.html" name="scredis.commands.HyperLogLogCommands" id="scredis.commands.HyperLogLogCommands" class="extype">HyperLogLogCommands</a></dd><dt>Since</dt><dd><p>2.8.9</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if at least one key is not of HyperLogLog type</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>The HyperLogLog data structure can be used in order to count unique elements in a set
using just a small constant amount of memory, specifically 12k bytes for every HyperLogLog
(plus a few bytes for the key itself).
The returned cardinality of the observed set is not exact, but approximated with a standard
error of 0.81%.</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.HyperLogLogCommands#pfMerge" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="pfMerge(destKey:String,keys:String*):scala.concurrent.Future[Unit]"></a><a id="pfMerge(String,String*):Future[Unit]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#pfMerge(destKey:String,keys:String*):scala.concurrent.Future[Unit]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">pfMerge</span><span class="params">(<span name="destKey">destKey: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="keys">keys: <span name="scala.Predef.String" class="extype">String</span>*</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span></span><p class="shortcomment cmt">Merge multiple HyperLogLog values into an unique value that will approximate the cardinality
of the union of the observed Sets of the source HyperLogLog structures.</p><div class="fullcomment"><div class="comment cmt"><p>Merge multiple HyperLogLog values into an unique value that will approximate the cardinality
of the union of the observed Sets of the source HyperLogLog structures.</p><p>The computed merged HyperLogLog is set to the destination variable, which is created if does
not exist (defauling to an empty HyperLogLog).
</p></div><dl class="paramcmts block"><dt class="param">destKey</dt><dd class="cmt"><p>the destination key where the result should be stored</p></dd><dt class="param">keys</dt><dd class="cmt"><p>keys of the HyperLogLog data structure to merge</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/HyperLogLogCommands.html" name="scredis.commands.HyperLogLogCommands" id="scredis.commands.HyperLogLogCommands" class="extype">HyperLogLogCommands</a></dd><dt>Since</dt><dd><p>2.8.9</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if at least one key is not of HyperLogLog type</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>The HyperLogLog data structure can be used in order to count unique elements in a set
using just a small constant amount of memory, specifically 12k bytes for every HyperLogLog
(plus a few bytes for the key itself).
The returned cardinality of the observed set is not exact, but approximated with a standard
error of 0.81%.</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.PubSubCommands#pubSubChannels" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="pubSubChannels(patternOpt:Option[String]):scala.concurrent.Future[List[String]]"></a><a id="pubSubChannels(Option[String]):Future[List[String]]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#pubSubChannels(patternOpt:Option[String]):scala.concurrent.Future[List[String]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">pubSubChannels</span><span class="params">(<span name="patternOpt">patternOpt: <a href="https://www.scala-lang.org/api/2.13.1/scala/Option.html#scala.Option" name="scala.Option" id="scala.Option" class="extype">Option</a>[<span name="scala.Predef.String" class="extype">String</span>] = <span class="symbol">None</span></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="scala.List" class="extype">List</span>[<span name="scala.Predef.String" class="extype">String</span>]]</span></span><p class="shortcomment cmt">Lists the currently active channels.</p><div class="fullcomment"><div class="comment cmt"><p>Lists the currently active channels. An active channel is a Pub/Sub channel with one or more
subscribers (not including clients subscribed to patterns).
</p></div><dl class="paramcmts block"><dt class="param">patternOpt</dt><dd class="cmt"><p>optional pattern to filter returned channels</p></dd><dt>returns</dt><dd class="cmt"><p>the currently active channels, optionally matching the specified pattern</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/PubSubCommands.html" name="scredis.commands.PubSubCommands" id="scredis.commands.PubSubCommands" class="extype">PubSubCommands</a></dd><dt>Since</dt><dd><p>2.8.0</p></dd><dt>Note</dt><dd><span class="cmt"><p>If no pattern is specified, all the channels are listed, otherwise if pattern is
specified only channels matching the specified glob-style pattern are listed.</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.PubSubCommands#pubSubNumPat" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="pubSubNumPat():scala.concurrent.Future[Long]"></a><a id="pubSubNumPat():Future[Long]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#pubSubNumPat():scala.concurrent.Future[Long]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">pubSubNumPat</span><span class="params">()</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a>]</span></span><p class="shortcomment cmt">Returns the number of subscriptions to patterns (that are performed using the
PSUBSCRIBE command).</p><div class="fullcomment"><div class="comment cmt"><p>Returns the number of subscriptions to patterns (that are performed using the
PSUBSCRIBE command).
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>the number of subscriptions to patterns</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/PubSubCommands.html" name="scredis.commands.PubSubCommands" id="scredis.commands.PubSubCommands" class="extype">PubSubCommands</a></dd><dt>Since</dt><dd><p>2.8.0</p></dd><dt>Note</dt><dd><span class="cmt"><p>Note that this is not just the count of clients subscribed to patterns but the total
number of patterns all the clients are subscribed to.</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.PubSubCommands#pubSubNumSub" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="pubSubNumSub(channels:String*):scala.concurrent.Future[Map[String,Long]]"></a><a id="pubSubNumSub(String*):Future[Map[String,Long]]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#pubSubNumSub(channels:String*):scala.concurrent.Future[Map[String,Long]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">pubSubNumSub</span><span class="params">(<span name="channels">channels: <span name="scala.Predef.String" class="extype">String</span>*</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="scala.Predef.Map" class="extype">Map</span>[<span name="scala.Predef.String" class="extype">String</span>, <a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a>]]</span></span><p class="shortcomment cmt">Returns the number of subscribers (not counting clients subscribed to patterns) for the
specified channels.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the number of subscribers (not counting clients subscribed to patterns) for the
specified channels.
</p></div><dl class="paramcmts block"><dt class="param">channels</dt><dd class="cmt"><p>channel name(s)</p></dd><dt>returns</dt><dd class="cmt"><p>a map of channels to number of subscribers for every provided channel</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/PubSubCommands.html" name="scredis.commands.PubSubCommands" id="scredis.commands.PubSubCommands" class="extype">PubSubCommands</a></dd><dt>Since</dt><dd><p>2.8.0</p></dd></dl></div></li><li class="indented0 " name="scredis.commands.PubSubCommands#publish" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="publish[W](channel:String,message:W)(implicitevidence$1:scredis.serialization.Writer[W]):scala.concurrent.Future[Long]"></a><a id="publish[W](String,W)(Writer[W]):Future[Long]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#publish[W](channel:String,message:W)(implicitevidence$1:scredis.serialization.Writer[W]):scala.concurrent.Future[Long]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">publish</span><span class="tparams">[<span name="W">W</span>]</span><span class="params">(<span name="channel">channel: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="message">message: <span name="scredis.commands.PubSubCommands.publish.W" class="extype">W</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Writer.html" name="scredis.serialization.Writer" id="scredis.serialization.Writer" class="extype">Writer</a>[<span name="scredis.commands.PubSubCommands.publish.W" class="extype">W</span>]</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a>]</span></span><p class="shortcomment cmt">Publishes a message to a channel.</p><div class="fullcomment"><div class="comment cmt"><p>Publishes a message to a channel.
</p></div><dl class="paramcmts block"><dt class="param">channel</dt><dd class="cmt"><p>the name of the channel</p></dd><dt class="param">message</dt><dd class="cmt"><p>the message payload</p></dd><dt>returns</dt><dd class="cmt"><p>the number of clients that received the message</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/PubSubCommands.html" name="scredis.commands.PubSubCommands" id="scredis.commands.PubSubCommands" class="extype">PubSubCommands</a></dd><dt>Since</dt><dd><p>2.0.0</p></dd></dl></div></li><li class="indented0 " name="scredis.commands.ListCommands#rPop" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="rPop[R](key:String)(implicitevidence$10:scredis.serialization.Reader[R]):scala.concurrent.Future[Option[R]]"></a><a id="rPop[R](String)(Reader[R]):Future[Option[R]]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#rPop[R](key:String)(implicitevidence$10:scredis.serialization.Reader[R]):scala.concurrent.Future[Option[R]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">rPop</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Reader.html" name="scredis.serialization.Reader" id="scredis.serialization.Reader" class="extype">Reader</a>[<span name="scredis.commands.ListCommands.rPop.R" class="extype">R</span>]</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Option.html#scala.Option" name="scala.Option" id="scala.Option" class="extype">Option</a>[<span name="scredis.commands.ListCommands.rPop.R" class="extype">R</span>]]</span></span><p class="shortcomment cmt">Removes and returns the last element of a list.</p><div class="fullcomment"><div class="comment cmt"><p>Removes and returns the last element of a list.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>list key</p></dd><dt>returns</dt><dd class="cmt"><p>the popped element, or <code>None</code> if the key does not exist</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/ListCommands.html" name="scredis.commands.ListCommands" id="scredis.commands.ListCommands" class="extype">ListCommands</a></dd><dt>Since</dt><dd><p>1.0.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if key contains a non-list value</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.ListCommands#rPopLPush" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="rPopLPush[R](sourceKey:String,destKey:String)(implicitevidence$11:scredis.serialization.Reader[R]):scala.concurrent.Future[Option[R]]"></a><a id="rPopLPush[R](String,String)(Reader[R]):Future[Option[R]]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#rPopLPush[R](sourceKey:String,destKey:String)(implicitevidence$11:scredis.serialization.Reader[R]):scala.concurrent.Future[Option[R]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">rPopLPush</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="sourceKey">sourceKey: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="destKey">destKey: <span name="scala.Predef.String" class="extype">String</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Reader.html" name="scredis.serialization.Reader" id="scredis.serialization.Reader" class="extype">Reader</a>[<span name="scredis.commands.ListCommands.rPopLPush.R" class="extype">R</span>]</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Option.html#scala.Option" name="scala.Option" id="scala.Option" class="extype">Option</a>[<span name="scredis.commands.ListCommands.rPopLPush.R" class="extype">R</span>]]</span></span><p class="shortcomment cmt">Removes the last element in a list, appends it to another list and returns it.</p><div class="fullcomment"><div class="comment cmt"><p>Removes the last element in a list, appends it to another list and returns it.
</p></div><dl class="paramcmts block"><dt class="param">sourceKey</dt><dd class="cmt"><p>key of list to be pop from</p></dd><dt class="param">destKey</dt><dd class="cmt"><p>key of list to be push to</p></dd><dt>returns</dt><dd class="cmt"><p>the popped element, or <code>None</code> if the key does not exist</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/ListCommands.html" name="scredis.commands.ListCommands" id="scredis.commands.ListCommands" class="extype">ListCommands</a></dd><dt>Since</dt><dd><p>1.2.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if key contains a non-list value</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.ListCommands#rPush" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="rPush[W](key:String,values:W*)(implicitevidence$12:scredis.serialization.Writer[W]):scala.concurrent.Future[Long]"></a><a id="rPush[W](String,W*)(Writer[W]):Future[Long]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#rPush[W](key:String,values:W*)(implicitevidence$12:scredis.serialization.Writer[W]):scala.concurrent.Future[Long]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">rPush</span><span class="tparams">[<span name="W">W</span>]</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="values">values: <span name="scredis.commands.ListCommands.rPush.W" class="extype">W</span>*</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Writer.html" name="scredis.serialization.Writer" id="scredis.serialization.Writer" class="extype">Writer</a>[<span name="scredis.commands.ListCommands.rPush.W" class="extype">W</span>]</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a>]</span></span><p class="shortcomment cmt">Appends one or multiple values to a list.</p><div class="fullcomment"><div class="comment cmt"><p>Appends one or multiple values to a list.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>list key</p></dd><dt class="param">values</dt><dd class="cmt"><p>value(s) to prepend</p></dd><dt>returns</dt><dd class="cmt"><p>the length of the list after the push operations</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/ListCommands.html" name="scredis.commands.ListCommands" id="scredis.commands.ListCommands" class="extype">ListCommands</a></dd><dt>Since</dt><dd><p>1.0.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if key contains a non-list value</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>If key does not exist, it is created as empty list before performing the push operation.
Redis versions older than 2.4 can only push one value per call.</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.ListCommands#rPushX" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="rPushX[W](key:String,value:W)(implicitevidence$13:scredis.serialization.Writer[W]):scala.concurrent.Future[Long]"></a><a id="rPushX[W](String,W)(Writer[W]):Future[Long]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#rPushX[W](key:String,value:W)(implicitevidence$13:scredis.serialization.Writer[W]):scala.concurrent.Future[Long]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">rPushX</span><span class="tparams">[<span name="W">W</span>]</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="value">value: <span name="scredis.commands.ListCommands.rPushX.W" class="extype">W</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Writer.html" name="scredis.serialization.Writer" id="scredis.serialization.Writer" class="extype">Writer</a>[<span name="scredis.commands.ListCommands.rPushX.W" class="extype">W</span>]</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a>]</span></span><p class="shortcomment cmt">Appends a value to a list, only if the list exists.</p><div class="fullcomment"><div class="comment cmt"><p>Appends a value to a list, only if the list exists.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>list key</p></dd><dt class="param">value</dt><dd class="cmt"><p>value to prepend</p></dd><dt>returns</dt><dd class="cmt"><p>the length of the list after the push operation</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/ListCommands.html" name="scredis.commands.ListCommands" id="scredis.commands.ListCommands" class="extype">ListCommands</a></dd><dt>Since</dt><dd><p>2.2.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if key contains a non-list value</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.KeyCommands#randomKey" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="randomKey():scala.concurrent.Future[Option[String]]"></a><a id="randomKey():Future[Option[String]]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#randomKey():scala.concurrent.Future[Option[String]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">randomKey</span><span class="params">()</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Option.html#scala.Option" name="scala.Option" id="scala.Option" class="extype">Option</a>[<span name="scala.Predef.String" class="extype">String</span>]]</span></span><p class="shortcomment cmt">Returns a random key from the keyspace.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a random key from the keyspace.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>the random key or <code>None</code> when the database is empty
associated timeout</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/KeyCommands.html" name="scredis.commands.KeyCommands" id="scredis.commands.KeyCommands" class="extype">KeyCommands</a></dd><dt>Since</dt><dd><p>1.0.0</p></dd></dl></div></li><li class="indented0 " name="scredis.commands.KeyCommands#rename" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="rename(key:String,newKey:String):scala.concurrent.Future[Unit]"></a><a id="rename(String,String):Future[Unit]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#rename(key:String,newKey:String):scala.concurrent.Future[Unit]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">rename</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="newKey">newKey: <span name="scala.Predef.String" class="extype">String</span></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span></span><p class="shortcomment cmt">Renames a key.</p><div class="fullcomment"><div class="comment cmt"><p>Renames a key.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>source key</p></dd><dt class="param">newKey</dt><dd class="cmt"><p>destination key</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/KeyCommands.html" name="scredis.commands.KeyCommands" id="scredis.commands.KeyCommands" class="extype">KeyCommands</a></dd><dt>Since</dt><dd><p>1.0.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if the source and destination keys are the same, or when key
does not exist</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>if newKey already exists, it is overwritten</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.KeyCommands#renameNX" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="renameNX(key:String,newKey:String):scala.concurrent.Future[Boolean]"></a><a id="renameNX(String,String):Future[Boolean]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#renameNX(key:String,newKey:String):scala.concurrent.Future[Boolean]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">renameNX</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="newKey">newKey: <span name="scala.Predef.String" class="extype">String</span></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a>]</span></span><p class="shortcomment cmt">Renames a key, only if the new key does not exist.</p><div class="fullcomment"><div class="comment cmt"><p>Renames a key, only if the new key does not exist.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>source key</p></dd><dt class="param">newKey</dt><dd class="cmt"><p>destination key</p></dd><dt>returns</dt><dd class="cmt"><p><b>true</b> if key was renamed to newKey, <b>false</b> if newKey already exists</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/KeyCommands.html" name="scredis.commands.KeyCommands" id="scredis.commands.KeyCommands" class="extype">KeyCommands</a></dd><dt>Since</dt><dd><p>1.0.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if the source and destination keys are the same, or when key does not exist</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.KeyCommands#restore" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="restore[W](key:String,serializedValue:W,ttlOpt:Option[scala.concurrent.duration.FiniteDuration])(implicitevidence$1:scredis.serialization.Writer[W]):scala.concurrent.Future[Unit]"></a><a id="restore[W](String,W,Option[FiniteDuration])(Writer[W]):Future[Unit]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#restore[W](key:String,serializedValue:W,ttlOpt:Option[scala.concurrent.duration.FiniteDuration])(implicitevidence$1:scredis.serialization.Writer[W]):scala.concurrent.Future[Unit]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">restore</span><span class="tparams">[<span name="W">W</span>]</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="serializedValue">serializedValue: <span name="scredis.commands.KeyCommands.restore.W" class="extype">W</span></span>, <span name="ttlOpt">ttlOpt: <a href="https://www.scala-lang.org/api/2.13.1/scala/Option.html#scala.Option" name="scala.Option" id="scala.Option" class="extype">Option</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/duration/FiniteDuration.html#scala.concurrent.duration.FiniteDuration" name="scala.concurrent.duration.FiniteDuration" id="scala.concurrent.duration.FiniteDuration" class="extype">FiniteDuration</a>] = <span class="symbol">None</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Writer.html" name="scredis.serialization.Writer" id="scredis.serialization.Writer" class="extype">Writer</a>[<span name="scredis.commands.KeyCommands.restore.W" class="extype">W</span>]</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span></span><p class="shortcomment cmt">Creates a key using the provided serialized value, previously obtained using DUMP.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a key using the provided serialized value, previously obtained using DUMP.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>destination key</p></dd><dt class="param">serializedValue</dt><dd class="cmt"><p>serialized value, previously obtained using DUMP</p></dd><dt class="param">ttlOpt</dt><dd class="cmt"><p>optional time-to-live duration of newly created key (expire)</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/KeyCommands.html" name="scredis.commands.KeyCommands" id="scredis.commands.KeyCommands" class="extype">KeyCommands</a></dd><dt>Since</dt><dd><p>2.6.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if the value could not be restored</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.SetCommands#sAdd" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="sAdd[W](key:String,members:W*)(implicitevidence$1:scredis.serialization.Writer[W]):scala.concurrent.Future[Long]"></a><a id="sAdd[W](String,W*)(Writer[W]):Future[Long]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#sAdd[W](key:String,members:W*)(implicitevidence$1:scredis.serialization.Writer[W]):scala.concurrent.Future[Long]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">sAdd</span><span class="tparams">[<span name="W">W</span>]</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="members">members: <span name="scredis.commands.SetCommands.sAdd.W" class="extype">W</span>*</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Writer.html" name="scredis.serialization.Writer" id="scredis.serialization.Writer" class="extype">Writer</a>[<span name="scredis.commands.SetCommands.sAdd.W" class="extype">W</span>]</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a>]</span></span><p class="shortcomment cmt">Adds one or more members to a set.</p><div class="fullcomment"><div class="comment cmt"><p>Adds one or more members to a set.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>set key</p></dd><dt class="param">members</dt><dd class="cmt"><p>member(s) to add</p></dd><dt>returns</dt><dd class="cmt"><p>the number of members added to the set, not including all the members that were
already present</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/SetCommands.html" name="scredis.commands.SetCommands" id="scredis.commands.SetCommands" class="extype">SetCommands</a></dd><dt>Since</dt><dd><p>1.0.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if key contains a value that is not a set</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.SetCommands#sCard" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="sCard(key:String):scala.concurrent.Future[Long]"></a><a id="sCard(String):Future[Long]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#sCard(key:String):scala.concurrent.Future[Long]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">sCard</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a>]</span></span><p class="shortcomment cmt">Returns the number of members in a set.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the number of members in a set.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>set key</p></dd><dt>returns</dt><dd class="cmt"><p>the cardinality (number of members) of the set, or 0 if key does not exist</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/SetCommands.html" name="scredis.commands.SetCommands" id="scredis.commands.SetCommands" class="extype">SetCommands</a></dd><dt>Since</dt><dd><p>1.0.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if key contains a value that is not a set</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.SetCommands#sDiff" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="sDiff[R](key:String,keys:String*)(implicitevidence$2:scredis.serialization.Reader[R]):scala.concurrent.Future[Set[R]]"></a><a id="sDiff[R](String,String*)(Reader[R]):Future[Set[R]]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#sDiff[R](key:String,keys:String*)(implicitevidence$2:scredis.serialization.Reader[R]):scala.concurrent.Future[Set[R]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">sDiff</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="keys">keys: <span name="scala.Predef.String" class="extype">String</span>*</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Reader.html" name="scredis.serialization.Reader" id="scredis.serialization.Reader" class="extype">Reader</a>[<span name="scredis.commands.SetCommands.sDiff.R" class="extype">R</span>]</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="scala.Predef.Set" class="extype">Set</span>[<span name="scredis.commands.SetCommands.sDiff.R" class="extype">R</span>]]</span></span><p class="shortcomment cmt">Returns the set resulting from the difference between the first set and all the successive
sets.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the set resulting from the difference between the first set and all the successive
sets.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>the key of the first set</p></dd><dt class="param">keys</dt><dd class="cmt"><p>key(s) of successive set(s) whose members will be substracted from the first one</p></dd><dt>returns</dt><dd class="cmt"><p>the resulting set, or the empty set if the first key does not exist</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/SetCommands.html" name="scredis.commands.SetCommands" id="scredis.commands.SetCommands" class="extype">SetCommands</a></dd><dt>Since</dt><dd><p>1.0.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if some keys contain a value that is not a set</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.SetCommands#sDiffStore" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="sDiffStore(destKey:String,key:String,keys:String*):scala.concurrent.Future[Long]"></a><a id="sDiffStore(String,String,String*):Future[Long]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#sDiffStore(destKey:String,key:String,keys:String*):scala.concurrent.Future[Long]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">sDiffStore</span><span class="params">(<span name="destKey">destKey: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="keys">keys: <span name="scala.Predef.String" class="extype">String</span>*</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a>]</span></span><p class="shortcomment cmt">Stores the set resulting from the difference between the first set and all the successive sets.</p><div class="fullcomment"><div class="comment cmt"><p>Stores the set resulting from the difference between the first set and all the successive sets.
</p></div><dl class="paramcmts block"><dt class="param">destKey</dt><dd class="cmt"><p>key where to store the resulting set</p></dd><dt class="param">key</dt><dd class="cmt"><p>key of first set</p></dd><dt class="param">keys</dt><dd class="cmt"><p>keys of sets to be substracted from first set, if empty, first set is simply
copied to destKey</p></dd><dt>returns</dt><dd class="cmt"><p>the cardinality of the resulting set</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/SetCommands.html" name="scredis.commands.SetCommands" id="scredis.commands.SetCommands" class="extype">SetCommands</a></dd><dt>Since</dt><dd><p>1.0.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if some keys contain a value that is not a set</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>If destKey already exists, it is overwritten.</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.SetCommands#sInter" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="sInter[R](keys:String*)(implicitevidence$3:scredis.serialization.Reader[R]):scala.concurrent.Future[Set[R]]"></a><a id="sInter[R](String*)(Reader[R]):Future[Set[R]]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#sInter[R](keys:String*)(implicitevidence$3:scredis.serialization.Reader[R]):scala.concurrent.Future[Set[R]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">sInter</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="keys">keys: <span name="scala.Predef.String" class="extype">String</span>*</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Reader.html" name="scredis.serialization.Reader" id="scredis.serialization.Reader" class="extype">Reader</a>[<span name="scredis.commands.SetCommands.sInter.R" class="extype">R</span>]</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="scala.Predef.Set" class="extype">Set</span>[<span name="scredis.commands.SetCommands.sInter.R" class="extype">R</span>]]</span></span><p class="shortcomment cmt">Intersects multiple sets.</p><div class="fullcomment"><div class="comment cmt"><p>Intersects multiple sets.
</p></div><dl class="paramcmts block"><dt class="param">keys</dt><dd class="cmt"><p>keys of sets to be intersected together</p></dd><dt>returns</dt><dd class="cmt"><p>the resulting set, or the empty set if the first key does not exist</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/SetCommands.html" name="scredis.commands.SetCommands" id="scredis.commands.SetCommands" class="extype">SetCommands</a></dd><dt>Since</dt><dd><p>1.0.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if some keys contain a value that is not a set</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.SetCommands#sInterStore" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="sInterStore(destKey:String,keys:String*):scala.concurrent.Future[Long]"></a><a id="sInterStore(String,String*):Future[Long]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#sInterStore(destKey:String,keys:String*):scala.concurrent.Future[Long]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">sInterStore</span><span class="params">(<span name="destKey">destKey: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="keys">keys: <span name="scala.Predef.String" class="extype">String</span>*</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a>]</span></span><p class="shortcomment cmt">Intersects multiple sets and stores the resulting set in a key.</p><div class="fullcomment"><div class="comment cmt"><p>Intersects multiple sets and stores the resulting set in a key.
</p></div><dl class="paramcmts block"><dt class="param">destKey</dt><dd class="cmt"><p>key where to store the resulting set</p></dd><dt class="param">keys</dt><dd class="cmt"><p>keys of sets to be intersected together, if only one is specified, it is simply
copied to destKey</p></dd><dt>returns</dt><dd class="cmt"><p>the cardinality of the resulting set</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/SetCommands.html" name="scredis.commands.SetCommands" id="scredis.commands.SetCommands" class="extype">SetCommands</a></dd><dt>Since</dt><dd><p>1.0.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if some keys contain a value that is not a set</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>If destKey already exists, it is overwritten.</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.SetCommands#sIsMember" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="sIsMember[W](key:String,member:W)(implicitevidence$4:scredis.serialization.Writer[W]):scala.concurrent.Future[Boolean]"></a><a id="sIsMember[W](String,W)(Writer[W]):Future[Boolean]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#sIsMember[W](key:String,member:W)(implicitevidence$4:scredis.serialization.Writer[W]):scala.concurrent.Future[Boolean]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">sIsMember</span><span class="tparams">[<span name="W">W</span>]</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="member">member: <span name="scredis.commands.SetCommands.sIsMember.W" class="extype">W</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Writer.html" name="scredis.serialization.Writer" id="scredis.serialization.Writer" class="extype">Writer</a>[<span name="scredis.commands.SetCommands.sIsMember.W" class="extype">W</span>]</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a>]</span></span><p class="shortcomment cmt">Determines if a given value is a member of a set.</p><div class="fullcomment"><div class="comment cmt"><p>Determines if a given value is a member of a set.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>set key</p></dd><dt class="param">member</dt><dd class="cmt"><p>value to be tested</p></dd><dt>returns</dt><dd class="cmt"><p><b>true</b> if the provided value is a member of the set stored at key, <b>false</b> otherwise</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/SetCommands.html" name="scredis.commands.SetCommands" id="scredis.commands.SetCommands" class="extype">SetCommands</a></dd><dt>Since</dt><dd><p>1.0.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if key contains a value that is not a set</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.SetCommands#sMembers" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="sMembers[R](key:String)(implicitevidence$5:scredis.serialization.Reader[R]):scala.concurrent.Future[Set[R]]"></a><a id="sMembers[R](String)(Reader[R]):Future[Set[R]]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#sMembers[R](key:String)(implicitevidence$5:scredis.serialization.Reader[R]):scala.concurrent.Future[Set[R]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">sMembers</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Reader.html" name="scredis.serialization.Reader" id="scredis.serialization.Reader" class="extype">Reader</a>[<span name="scredis.commands.SetCommands.sMembers.R" class="extype">R</span>]</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="scala.Predef.Set" class="extype">Set</span>[<span name="scredis.commands.SetCommands.sMembers.R" class="extype">R</span>]]</span></span><p class="shortcomment cmt">Returns all the members of a set.</p><div class="fullcomment"><div class="comment cmt"><p>Returns all the members of a set.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>set key</p></dd><dt>returns</dt><dd class="cmt"><p>set stored at key, or the empty set if key does not exist</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/SetCommands.html" name="scredis.commands.SetCommands" id="scredis.commands.SetCommands" class="extype">SetCommands</a></dd><dt>Since</dt><dd><p>1.0.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if key contains a value that is not a set</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.SetCommands#sMove" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="sMove[W](sourceKey:String,destKey:String,member:W)(implicitevidence$6:scredis.serialization.Writer[W]):scala.concurrent.Future[Boolean]"></a><a id="sMove[W](String,String,W)(Writer[W]):Future[Boolean]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#sMove[W](sourceKey:String,destKey:String,member:W)(implicitevidence$6:scredis.serialization.Writer[W]):scala.concurrent.Future[Boolean]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">sMove</span><span class="tparams">[<span name="W">W</span>]</span><span class="params">(<span name="sourceKey">sourceKey: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="destKey">destKey: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="member">member: <span name="scredis.commands.SetCommands.sMove.W" class="extype">W</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Writer.html" name="scredis.serialization.Writer" id="scredis.serialization.Writer" class="extype">Writer</a>[<span name="scredis.commands.SetCommands.sMove.W" class="extype">W</span>]</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a>]</span></span><p class="shortcomment cmt">Moves a member from one set to another.</p><div class="fullcomment"><div class="comment cmt"><p>Moves a member from one set to another.
</p></div><dl class="paramcmts block"><dt class="param">sourceKey</dt><dd class="cmt"><p>key of source set</p></dd><dt class="param">member</dt><dd class="cmt"><p>value to be moved from source set to destination set</p></dd><dt>returns</dt><dd class="cmt"><p><b>true</b> if the member was moved, <b>false</b> if the element is not a member of source set and
no operation was performed</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/SetCommands.html" name="scredis.commands.SetCommands" id="scredis.commands.SetCommands" class="extype">SetCommands</a></dd><dt>Since</dt><dd><p>1.0.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if sourceKey or destKey contains a value that is not a set</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.SetCommands#sPop" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="sPop[R](key:String)(implicitevidence$7:scredis.serialization.Reader[R]):scala.concurrent.Future[Option[R]]"></a><a id="sPop[R](String)(Reader[R]):Future[Option[R]]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#sPop[R](key:String)(implicitevidence$7:scredis.serialization.Reader[R]):scala.concurrent.Future[Option[R]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">sPop</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Reader.html" name="scredis.serialization.Reader" id="scredis.serialization.Reader" class="extype">Reader</a>[<span name="scredis.commands.SetCommands.sPop.R" class="extype">R</span>]</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Option.html#scala.Option" name="scala.Option" id="scala.Option" class="extype">Option</a>[<span name="scredis.commands.SetCommands.sPop.R" class="extype">R</span>]]</span></span><p class="shortcomment cmt">Removes and returns a random member from a set.</p><div class="fullcomment"><div class="comment cmt"><p>Removes and returns a random member from a set.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>set key</p></dd><dt>returns</dt><dd class="cmt"><p>random member, or <code>None</code> if key does not exist</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/SetCommands.html" name="scredis.commands.SetCommands" id="scredis.commands.SetCommands" class="extype">SetCommands</a></dd><dt>Since</dt><dd><p>1.0.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if key contains a value that is not a set</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>This operation is similar to SRANDMEMBER, that returns a random element from a set but
does not remove it.</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.SetCommands#sPopCount" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="sPopCount[R](key:String,count:Int)(implicitevidence$8:scredis.serialization.Reader[R]):scala.concurrent.Future[List[R]]"></a><a id="sPopCount[R](String,Int)(Reader[R]):Future[List[R]]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#sPopCount[R](key:String,count:Int)(implicitevidence$8:scredis.serialization.Reader[R]):scala.concurrent.Future[List[R]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">sPopCount</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="count">count: <a href="https://www.scala-lang.org/api/2.13.1/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Reader.html" name="scredis.serialization.Reader" id="scredis.serialization.Reader" class="extype">Reader</a>[<span name="scredis.commands.SetCommands.sPopCount.R" class="extype">R</span>]</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="scala.List" class="extype">List</span>[<span name="scredis.commands.SetCommands.sPopCount.R" class="extype">R</span>]]</span></span><p class="shortcomment cmt">Removes and returns a random 'count' members from a set.</p><div class="fullcomment"><div class="comment cmt"><p>Removes and returns a random 'count' members from a set.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>set key</p></dd><dt class="param">count</dt><dd class="cmt"><p>maximum number of returned elements</p></dd><dt>returns</dt><dd class="cmt"><p>list of random members which size is less or equal to 'count'</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/SetCommands.html" name="scredis.commands.SetCommands" id="scredis.commands.SetCommands" class="extype">SetCommands</a></dd><dt>Since</dt><dd><p>3.2.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if key contains a value that is not a set</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>This operation is similar to SRANDMEMBER, that returns a random element from a set but
does not remove it.</p></span></dd><dt>See also</dt><dd><span class="cmt"><p><a href="https://redis.io/commands/spop" target="_blank">https://redis.io/commands/spop</a></p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.SetCommands#sRandMember" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="sRandMember[R](key:String)(implicitevidence$9:scredis.serialization.Reader[R]):scala.concurrent.Future[Option[R]]"></a><a id="sRandMember[R](String)(Reader[R]):Future[Option[R]]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#sRandMember[R](key:String)(implicitevidence$9:scredis.serialization.Reader[R]):scala.concurrent.Future[Option[R]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">sRandMember</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Reader.html" name="scredis.serialization.Reader" id="scredis.serialization.Reader" class="extype">Reader</a>[<span name="scredis.commands.SetCommands.sRandMember.R" class="extype">R</span>]</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Option.html#scala.Option" name="scala.Option" id="scala.Option" class="extype">Option</a>[<span name="scredis.commands.SetCommands.sRandMember.R" class="extype">R</span>]]</span></span><p class="shortcomment cmt">Returns a random member from a set (without removing it).</p><div class="fullcomment"><div class="comment cmt"><p>Returns a random member from a set (without removing it).
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>set key</p></dd><dt>returns</dt><dd class="cmt"><p>random member, or <code>None</code> if key does not exist</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/SetCommands.html" name="scredis.commands.SetCommands" id="scredis.commands.SetCommands" class="extype">SetCommands</a></dd><dt>Since</dt><dd><p>1.0.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if key contains a value that is not a set</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.SetCommands#sRandMembers" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="sRandMembers[R](key:String,count:Int)(implicitevidence$10:scredis.serialization.Reader[R]):scala.concurrent.Future[Set[R]]"></a><a id="sRandMembers[R](String,Int)(Reader[R]):Future[Set[R]]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#sRandMembers[R](key:String,count:Int)(implicitevidence$10:scredis.serialization.Reader[R]):scala.concurrent.Future[Set[R]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">sRandMembers</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="count">count: <a href="https://www.scala-lang.org/api/2.13.1/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a> = <span class="symbol">1</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Reader.html" name="scredis.serialization.Reader" id="scredis.serialization.Reader" class="extype">Reader</a>[<span name="scredis.commands.SetCommands.sRandMembers.R" class="extype">R</span>]</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="scala.Predef.Set" class="extype">Set</span>[<span name="scredis.commands.SetCommands.sRandMembers.R" class="extype">R</span>]]</span></span><p class="shortcomment cmt">Returns a random member from a set (without removing it).</p><div class="fullcomment"><div class="comment cmt"><p>Returns a random member from a set (without removing it).
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>set key</p></dd><dt class="param">count</dt><dd class="cmt"><p>number of member to randomly retrieve</p></dd><dt>returns</dt><dd class="cmt"><p>set of random members, or the empty set if key does not exist</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/SetCommands.html" name="scredis.commands.SetCommands" id="scredis.commands.SetCommands" class="extype">SetCommands</a></dd><dt>Since</dt><dd><p>2.6.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if key contains a value that is not a set</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.SetCommands#sRem" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="sRem[W](key:String,members:W*)(implicitevidence$11:scredis.serialization.Writer[W]):scala.concurrent.Future[Long]"></a><a id="sRem[W](String,W*)(Writer[W]):Future[Long]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#sRem[W](key:String,members:W*)(implicitevidence$11:scredis.serialization.Writer[W]):scala.concurrent.Future[Long]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">sRem</span><span class="tparams">[<span name="W">W</span>]</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="members">members: <span name="scredis.commands.SetCommands.sRem.W" class="extype">W</span>*</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Writer.html" name="scredis.serialization.Writer" id="scredis.serialization.Writer" class="extype">Writer</a>[<span name="scredis.commands.SetCommands.sRem.W" class="extype">W</span>]</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a>]</span></span><p class="shortcomment cmt">Removes one or more members from a set.</p><div class="fullcomment"><div class="comment cmt"><p>Removes one or more members from a set.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>set key</p></dd><dt class="param">members</dt><dd class="cmt"><p>members to remove from set</p></dd><dt>returns</dt><dd class="cmt"><p>the number of members that were removed from the set, not including non-existing
members</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/SetCommands.html" name="scredis.commands.SetCommands" id="scredis.commands.SetCommands" class="extype">SetCommands</a></dd><dt>Since</dt><dd><p>1.0.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if key contains a value that is not a set</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>Redis versions older than 2.4 can only remove one member per call.</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.SetCommands#sScan" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="sScan[R](key:String,cursor:Long,matchOpt:Option[String],countOpt:Option[Int])(implicitevidence$12:scredis.serialization.Reader[R]):scala.concurrent.Future[(Long,Set[R])]"></a><a id="sScan[R](String,Long,Option[String],Option[Int])(Reader[R]):Future[(Long,Set[R])]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#sScan[R](key:String,cursor:Long,matchOpt:Option[String],countOpt:Option[Int])(implicitevidence$12:scredis.serialization.Reader[R]):scala.concurrent.Future[(Long,Set[R])]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">sScan</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="cursor">cursor: <a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a></span>, <span name="matchOpt">matchOpt: <a href="https://www.scala-lang.org/api/2.13.1/scala/Option.html#scala.Option" name="scala.Option" id="scala.Option" class="extype">Option</a>[<span name="scala.Predef.String" class="extype">String</span>] = <span class="symbol">None</span></span>, <span name="countOpt">countOpt: <a href="https://www.scala-lang.org/api/2.13.1/scala/Option.html#scala.Option" name="scala.Option" id="scala.Option" class="extype">Option</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a>] = <span class="symbol">None</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Reader.html" name="scredis.serialization.Reader" id="scredis.serialization.Reader" class="extype">Reader</a>[<span name="scredis.commands.SetCommands.sScan.R" class="extype">R</span>]</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[(<a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a>, <span name="scala.Predef.Set" class="extype">Set</span>[<span name="scredis.commands.SetCommands.sScan.R" class="extype">R</span>])]</span></span><p class="shortcomment cmt">Incrementally iterates the elements of a set.</p><div class="fullcomment"><div class="comment cmt"><p>Incrementally iterates the elements of a set.
</p></div><dl class="paramcmts block"><dt class="param">cursor</dt><dd class="cmt"><p>the offset</p></dd><dt class="param">matchOpt</dt><dd class="cmt"><p>when defined, the command only returns elements matching the pattern</p></dd><dt class="param">countOpt</dt><dd class="cmt"><p>when defined, provides a hint of how many elements should be returned</p></dd><dt>returns</dt><dd class="cmt"><p>a pair containing the next cursor as its first element and the set of elements
as its second element</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/SetCommands.html" name="scredis.commands.SetCommands" id="scredis.commands.SetCommands" class="extype">SetCommands</a></dd><dt>Since</dt><dd><p>2.8.0</p></dd></dl></div></li><li class="indented0 " name="scredis.commands.SetCommands#sUnion" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="sUnion[R](keys:String*)(implicitevidence$13:scredis.serialization.Reader[R]):scala.concurrent.Future[Set[R]]"></a><a id="sUnion[R](String*)(Reader[R]):Future[Set[R]]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#sUnion[R](keys:String*)(implicitevidence$13:scredis.serialization.Reader[R]):scala.concurrent.Future[Set[R]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">sUnion</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="keys">keys: <span name="scala.Predef.String" class="extype">String</span>*</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Reader.html" name="scredis.serialization.Reader" id="scredis.serialization.Reader" class="extype">Reader</a>[<span name="scredis.commands.SetCommands.sUnion.R" class="extype">R</span>]</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="scala.Predef.Set" class="extype">Set</span>[<span name="scredis.commands.SetCommands.sUnion.R" class="extype">R</span>]]</span></span><p class="shortcomment cmt">Computes the union of multiple sets.</p><div class="fullcomment"><div class="comment cmt"><p>Computes the union of multiple sets.
</p></div><dl class="paramcmts block"><dt class="param">keys</dt><dd class="cmt"><p>keys of sets to be included in the union computation</p></dd><dt>returns</dt><dd class="cmt"><p>the resulting set, or the empty set if the first key does not exist</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/SetCommands.html" name="scredis.commands.SetCommands" id="scredis.commands.SetCommands" class="extype">SetCommands</a></dd><dt>Since</dt><dd><p>1.0.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if some keys contain a value that is not a set</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.SetCommands#sUnionStore" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="sUnionStore(destKey:String,keys:String*):scala.concurrent.Future[Long]"></a><a id="sUnionStore(String,String*):Future[Long]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#sUnionStore(destKey:String,keys:String*):scala.concurrent.Future[Long]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">sUnionStore</span><span class="params">(<span name="destKey">destKey: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="keys">keys: <span name="scala.Predef.String" class="extype">String</span>*</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a>]</span></span><p class="shortcomment cmt">Computes the union of multiple sets and stores the resulting set in a key.</p><div class="fullcomment"><div class="comment cmt"><p>Computes the union of multiple sets and stores the resulting set in a key.
</p></div><dl class="paramcmts block"><dt class="param">destKey</dt><dd class="cmt"><p>key where to store the resulting set</p></dd><dt class="param">keys</dt><dd class="cmt"><p>keys of sets to be included in the union computation, if only one is specified,
it is simply copied to destKey</p></dd><dt>returns</dt><dd class="cmt"><p>the cardinality of the resulting set</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/SetCommands.html" name="scredis.commands.SetCommands" id="scredis.commands.SetCommands" class="extype">SetCommands</a></dd><dt>Since</dt><dd><p>1.0.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if some keys contain a value that is not a set</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>If destKey already exists, it is overwritten.</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.KeyCommands#scan" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="scan(cursor:Long,matchOpt:Option[String],countOpt:Option[Int]):scala.concurrent.Future[(Long,Set[String])]"></a><a id="scan(Long,Option[String],Option[Int]):Future[(Long,Set[String])]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#scan(cursor:Long,matchOpt:Option[String],countOpt:Option[Int]):scala.concurrent.Future[(Long,Set[String])]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">scan</span><span class="params">(<span name="cursor">cursor: <a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a></span>, <span name="matchOpt">matchOpt: <a href="https://www.scala-lang.org/api/2.13.1/scala/Option.html#scala.Option" name="scala.Option" id="scala.Option" class="extype">Option</a>[<span name="scala.Predef.String" class="extype">String</span>] = <span class="symbol">None</span></span>, <span name="countOpt">countOpt: <a href="https://www.scala-lang.org/api/2.13.1/scala/Option.html#scala.Option" name="scala.Option" id="scala.Option" class="extype">Option</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a>] = <span class="symbol">None</span></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[(<a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a>, <span name="scala.Predef.Set" class="extype">Set</span>[<span name="scala.Predef.String" class="extype">String</span>])]</span></span><p class="shortcomment cmt">Incrementally iterates the set of keys in the currently selected Redis database.</p><div class="fullcomment"><div class="comment cmt"><p>Incrementally iterates the set of keys in the currently selected Redis database.
</p></div><dl class="paramcmts block"><dt class="param">cursor</dt><dd class="cmt"><p>the offset</p></dd><dt class="param">matchOpt</dt><dd class="cmt"><p>when defined, the command only returns elements matching the pattern</p></dd><dt class="param">countOpt</dt><dd class="cmt"><p>when defined, provides a hint of how many elements should be returned</p></dd><dt>returns</dt><dd class="cmt"><p>a pair containing the next cursor as its first element and the set of keys
as its second element</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/KeyCommands.html" name="scredis.commands.KeyCommands" id="scredis.commands.KeyCommands" class="extype">KeyCommands</a></dd><dt>Since</dt><dd><p>2.8.0</p></dd></dl></div></li><li class="indented0 " name="scredis.commands.ScriptingCommands#scriptExists" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="scriptExists(sha1s:String*):scala.concurrent.Future[Map[String,Boolean]]"></a><a id="scriptExists(String*):Future[Map[String,Boolean]]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#scriptExists(sha1s:String*):scala.concurrent.Future[Map[String,Boolean]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">scriptExists</span><span class="params">(<span name="sha1s">sha1s: <span name="scala.Predef.String" class="extype">String</span>*</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="scala.Predef.Map" class="extype">Map</span>[<span name="scala.Predef.String" class="extype">String</span>, <a href="https://www.scala-lang.org/api/2.13.1/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a>]]</span></span><p class="shortcomment cmt">Checks existence of scripts in the script cache.</p><div class="fullcomment"><div class="comment cmt"><p>Checks existence of scripts in the script cache.
</p></div><dl class="paramcmts block"><dt class="param">sha1s</dt><dd class="cmt"><p>SHA1 digest(s) to check for existence</p></dd><dt>returns</dt><dd class="cmt"><p>SHA1 -&gt; Boolean <code>Map</code> where <b>true</b> means the script associated to the sha1 exists
in the cache</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/ScriptingCommands.html" name="scredis.commands.ScriptingCommands" id="scredis.commands.ScriptingCommands" class="extype">ScriptingCommands</a></dd><dt>Since</dt><dd><p>2.6.0</p></dd></dl></div></li><li class="indented0 " name="scredis.commands.ScriptingCommands#scriptFlush" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="scriptFlush():scala.concurrent.Future[Unit]"></a><a id="scriptFlush():Future[Unit]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#scriptFlush():scala.concurrent.Future[Unit]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">scriptFlush</span><span class="params">()</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span></span><p class="shortcomment cmt">Removes all the scripts from the script cache.</p><div class="fullcomment"><div class="comment cmt"><p>Removes all the scripts from the script cache.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/ScriptingCommands.html" name="scredis.commands.ScriptingCommands" id="scredis.commands.ScriptingCommands" class="extype">ScriptingCommands</a></dd><dt>Since</dt><dd><p>2.6.0</p></dd></dl></div></li><li class="indented0 " name="scredis.commands.ScriptingCommands#scriptKill" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="scriptKill():scala.concurrent.Future[Unit]"></a><a id="scriptKill():Future[Unit]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#scriptKill():scala.concurrent.Future[Unit]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">scriptKill</span><span class="params">()</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span></span><p class="shortcomment cmt">Kills the currently executing Lua script, assuming no write operation was yet performed by
the script.</p><div class="fullcomment"><div class="comment cmt"><p>Kills the currently executing Lua script, assuming no write operation was yet performed by
the script.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/ScriptingCommands.html" name="scredis.commands.ScriptingCommands" id="scredis.commands.ScriptingCommands" class="extype">ScriptingCommands</a></dd><dt>Since</dt><dd><p>2.6.0</p></dd><dt>Note</dt><dd><span class="cmt"><p>If the script already performed write operations it can not be killed in this way
because it would violate Lua script atomicity contract. In such a case only SHUTDOWN NOSAVE
is able to kill the script, killing the Redis process in an hard way preventing it to persist
with half-written information.</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.ScriptingCommands#scriptLoad" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="scriptLoad(script:String):scala.concurrent.Future[String]"></a><a id="scriptLoad(String):Future[String]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#scriptLoad(script:String):scala.concurrent.Future[String]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">scriptLoad</span><span class="params">(<span name="script">script: <span name="scala.Predef.String" class="extype">String</span></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="scala.Predef.String" class="extype">String</span>]</span></span><p class="shortcomment cmt">Loads or stores the specified Lua script into the script cache.</p><div class="fullcomment"><div class="comment cmt"><p>Loads or stores the specified Lua script into the script cache.
</p></div><dl class="paramcmts block"><dt class="param">script</dt><dd class="cmt"><p>the script to be loaded into the cache</p></dd><dt>returns</dt><dd class="cmt"><p>the SHA1 digest of the stored script</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/ScriptingCommands.html" name="scredis.commands.ScriptingCommands" id="scredis.commands.ScriptingCommands" class="extype">ScriptingCommands</a></dd><dt>Since</dt><dd><p>2.6.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if a compilation error occurs</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>The script is guaranteed to stay in the script cache forever (unless SCRIPT FLUSH
is called).</p></span></dd></dl></div></li><li class="indented0 " name="scredis.io.ClusterConnection#send" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="send[A](request:scredis.protocol.Request[A]):scala.concurrent.Future[A]"></a><a id="send[A](Request[A]):Future[A]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#send[A](request:scredis.protocol.Request[A]):scala.concurrent.Future[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">send</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="request">request: <a href="protocol/Request.html" name="scredis.protocol.Request" id="scredis.protocol.Request" class="extype">Request</a>[<span name="scredis.io.ClusterConnection.send.A" class="extype">A</span>]</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="scredis.io.ClusterConnection.send.A" class="extype">A</span>]</span></span><div class="fullcomment"><dl class="attributes block"><dt>Attributes</dt><dd>protected[<a href="index.html" name="scredis" id="scredis" class="extype">scredis</a>] </dd><dt>Definition Classes</dt><dd><a href="io/ClusterConnection.html" name="scredis.io.ClusterConnection" id="scredis.io.ClusterConnection" class="extype">ClusterConnection</a> → <a href="io/NonBlockingConnection.html" name="scredis.io.NonBlockingConnection" id="scredis.io.NonBlockingConnection" class="extype">NonBlockingConnection</a></dd></dl></div></li><li class="indented0 " name="scredis.commands.StringCommands#set" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="set[W](key:String,value:W,ttlOpt:Option[scala.concurrent.duration.FiniteDuration],conditionOpt:Option[scredis.Condition])(implicitevidence$11:scredis.serialization.Writer[W]):scala.concurrent.Future[Boolean]"></a><a id="set[W](String,W,Option[FiniteDuration],Option[Condition])(Writer[W]):Future[Boolean]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#set[W](key:String,value:W,ttlOpt:Option[scala.concurrent.duration.FiniteDuration],conditionOpt:Option[scredis.Condition])(implicitevidence$11:scredis.serialization.Writer[W]):scala.concurrent.Future[Boolean]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">set</span><span class="tparams">[<span name="W">W</span>]</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="value">value: <span name="scredis.commands.StringCommands.set.W" class="extype">W</span></span>, <span name="ttlOpt">ttlOpt: <a href="https://www.scala-lang.org/api/2.13.1/scala/Option.html#scala.Option" name="scala.Option" id="scala.Option" class="extype">Option</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/duration/FiniteDuration.html#scala.concurrent.duration.FiniteDuration" name="scala.concurrent.duration.FiniteDuration" id="scala.concurrent.duration.FiniteDuration" class="extype">FiniteDuration</a>] = <span class="symbol">None</span></span>, <span name="conditionOpt">conditionOpt: <a href="https://www.scala-lang.org/api/2.13.1/scala/Option.html#scala.Option" name="scala.Option" id="scala.Option" class="extype">Option</a>[<a href="package$$Condition.html" name="scredis.Condition" id="scredis.Condition" class="extype">Condition</a>] = <span class="symbol">None</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Writer.html" name="scredis.serialization.Writer" id="scredis.serialization.Writer" class="extype">Writer</a>[<span name="scredis.commands.StringCommands.set.W" class="extype">W</span>]</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a>]</span></span><p class="shortcomment cmt">Sets the string value of a key.</p><div class="fullcomment"><div class="comment cmt"><p>Sets the string value of a key.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>target key to set</p></dd><dt class="param">value</dt><dd class="cmt"><p>value to be stored at key</p></dd><dt class="param">ttlOpt</dt><dd class="cmt"><p>optional time-to-live (up to milliseconds precision)</p></dd><dt class="param">conditionOpt</dt><dd class="cmt"><p>optional condition to be met for the value to be set</p></dd><dt>returns</dt><dd class="cmt"><p><b>true</b> if the value was set correctly, <b>false</b> if a condition was specified but not met</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/StringCommands.html" name="scredis.commands.StringCommands" id="scredis.commands.StringCommands" class="extype">StringCommands</a></dd><dt>Since</dt><dd><p>1.0.0</p></dd><dt>Note</dt><dd><span class="cmt"><p>If key already holds a value, it is overwritten, regardless of its type. Any previous
time to live associated with the key is discarded on successful SET operation.
The ttlOpt and conditionOpt parameters can only be used with <code>Redis</code> &gt;= 2.6.12</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.StringCommands#setBit" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="setBit(key:String,offset:Long,bit:Boolean):scala.concurrent.Future[Boolean]"></a><a id="setBit(String,Long,Boolean):Future[Boolean]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#setBit(key:String,offset:Long,bit:Boolean):scala.concurrent.Future[Boolean]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">setBit</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="offset">offset: <a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a></span>, <span name="bit">bit: <a href="https://www.scala-lang.org/api/2.13.1/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a>]</span></span><p class="shortcomment cmt">Sets or clears the bit at offset in the string value stored at key.</p><div class="fullcomment"><div class="comment cmt"><p>Sets or clears the bit at offset in the string value stored at key.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>key for which the bit should be set</p></dd><dt class="param">offset</dt><dd class="cmt"><p>position where the bit should be set</p></dd><dt class="param">bit</dt><dd class="cmt"><p><b>true</b> sets the bit to 1, <b>false</b> sets it to 0</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/StringCommands.html" name="scredis.commands.StringCommands" id="scredis.commands.StringCommands" class="extype">StringCommands</a></dd><dt>Since</dt><dd><p>2.2.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if the key contains a value of the wrong type</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>When key does not exist, a new string value is created. The string is grown to make sure
it can hold a bit at offset. When the string at key is grown, added bits are set to 0.</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.StringCommands#setEX" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="setEX[W](key:String,value:W,ttlSeconds:Int)(implicitevidence$12:scredis.serialization.Writer[W]):scala.concurrent.Future[Unit]"></a><a id="setEX[W](String,W,Int)(Writer[W]):Future[Unit]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#setEX[W](key:String,value:W,ttlSeconds:Int)(implicitevidence$12:scredis.serialization.Writer[W]):scala.concurrent.Future[Unit]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">setEX</span><span class="tparams">[<span name="W">W</span>]</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="value">value: <span name="scredis.commands.StringCommands.setEX.W" class="extype">W</span></span>, <span name="ttlSeconds">ttlSeconds: <a href="https://www.scala-lang.org/api/2.13.1/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Writer.html" name="scredis.serialization.Writer" id="scredis.serialization.Writer" class="extype">Writer</a>[<span name="scredis.commands.StringCommands.setEX.W" class="extype">W</span>]</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span></span><p class="shortcomment cmt">Sets the value and expiration in seconds of a key.</p><div class="fullcomment"><div class="comment cmt"><p>Sets the value and expiration in seconds of a key.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>target key to set</p></dd><dt class="param">value</dt><dd class="cmt"><p>value to be stored at key</p></dd><dt class="param">ttlSeconds</dt><dd class="cmt"><p>time-to-live in seconds</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/StringCommands.html" name="scredis.commands.StringCommands" id="scredis.commands.StringCommands" class="extype">StringCommands</a></dd><dt>Since</dt><dd><p>2.0.0</p></dd><dt>Note</dt><dd><span class="cmt"><p>If key already holds a value, it is overwritten, regardless of its type.</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.StringCommands#setNX" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="setNX[W](key:String,value:W)(implicitevidence$13:scredis.serialization.Writer[W]):scala.concurrent.Future[Boolean]"></a><a id="setNX[W](String,W)(Writer[W]):Future[Boolean]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#setNX[W](key:String,value:W)(implicitevidence$13:scredis.serialization.Writer[W]):scala.concurrent.Future[Boolean]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">setNX</span><span class="tparams">[<span name="W">W</span>]</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="value">value: <span name="scredis.commands.StringCommands.setNX.W" class="extype">W</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Writer.html" name="scredis.serialization.Writer" id="scredis.serialization.Writer" class="extype">Writer</a>[<span name="scredis.commands.StringCommands.setNX.W" class="extype">W</span>]</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a>]</span></span><p class="shortcomment cmt">Sets the value of a key, only if the key does not exist.</p><div class="fullcomment"><div class="comment cmt"><p>Sets the value of a key, only if the key does not exist.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>target key to set</p></dd><dt class="param">value</dt><dd class="cmt"><p>value to be stored at key</p></dd><dt>returns</dt><dd class="cmt"><p><b>true</b> if the key was set, <b>false</b> otherwise</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/StringCommands.html" name="scredis.commands.StringCommands" id="scredis.commands.StringCommands" class="extype">StringCommands</a></dd><dt>Since</dt><dd><p>1.0.0</p></dd></dl></div></li><li class="indented0 " name="scredis.commands.StringCommands#setRange" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="setRange[W](key:String,offset:Long,value:W)(implicitevidence$14:scredis.serialization.Writer[W]):scala.concurrent.Future[Long]"></a><a id="setRange[W](String,Long,W)(Writer[W]):Future[Long]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#setRange[W](key:String,offset:Long,value:W)(implicitevidence$14:scredis.serialization.Writer[W]):scala.concurrent.Future[Long]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">setRange</span><span class="tparams">[<span name="W">W</span>]</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="offset">offset: <a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a></span>, <span name="value">value: <span name="scredis.commands.StringCommands.setRange.W" class="extype">W</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Writer.html" name="scredis.serialization.Writer" id="scredis.serialization.Writer" class="extype">Writer</a>[<span name="scredis.commands.StringCommands.setRange.W" class="extype">W</span>]</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a>]</span></span><p class="shortcomment cmt">Overwrites part of a string at key starting at the specified offset.</p><div class="fullcomment"><div class="comment cmt"><p>Overwrites part of a string at key starting at the specified offset.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>target key</p></dd><dt class="param">offset</dt><dd class="cmt"><p>position from which the string must be overwritten</p></dd><dt class="param">value</dt><dd class="cmt"><p>string value to be set at given offset</p></dd><dt>returns</dt><dd class="cmt"><p>the length of the string after it was modified by the command</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/StringCommands.html" name="scredis.commands.StringCommands" id="scredis.commands.StringCommands" class="extype">StringCommands</a></dd><dt>Since</dt><dd><p>2.2.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if the key contains a value of the wrong type</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>If the offset is larger than the current length of the string at key, the string is
padded with zero-bytes to make offset fit. Non-existing keys are considered as empty strings,
so this command will make sure it holds a string large enough to be able to set value at
offset.</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.KeyCommands#sort" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="sort[R](key:String,byOpt:Option[String],limitOpt:Option[(Long,Long)],get:Iterable[String],desc:Boolean,alpha:Boolean)(implicitevidence$2:scredis.serialization.Reader[R]):scala.concurrent.Future[List[Option[R]]]"></a><a id="sort[R](String,Option[String],Option[(Long,Long)],Iterable[String],Boolean,Boolean)(Reader[R]):Future[List[Option[R]]]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#sort[R](key:String,byOpt:Option[String],limitOpt:Option[(Long,Long)],get:Iterable[String],desc:Boolean,alpha:Boolean)(implicitevidence$2:scredis.serialization.Reader[R]):scala.concurrent.Future[List[Option[R]]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">sort</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="byOpt">byOpt: <a href="https://www.scala-lang.org/api/2.13.1/scala/Option.html#scala.Option" name="scala.Option" id="scala.Option" class="extype">Option</a>[<span name="scala.Predef.String" class="extype">String</span>] = <span class="symbol">None</span></span>, <span name="limitOpt">limitOpt: <a href="https://www.scala-lang.org/api/2.13.1/scala/Option.html#scala.Option" name="scala.Option" id="scala.Option" class="extype">Option</a>[(<a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a>, <a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a>)] = <span class="symbol">None</span></span>, <span name="get">get: <span name="scala.Iterable" class="extype">Iterable</span>[<span name="scala.Predef.String" class="extype">String</span>] = <span class="symbol">Nil</span></span>, <span name="desc">desc: <a href="https://www.scala-lang.org/api/2.13.1/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a> = <span class="symbol">false</span></span>, <span name="alpha">alpha: <a href="https://www.scala-lang.org/api/2.13.1/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a> = <span class="symbol">false</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Reader.html" name="scredis.serialization.Reader" id="scredis.serialization.Reader" class="extype">Reader</a>[<span name="scredis.commands.KeyCommands.sort.R" class="extype">R</span>]</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="scala.List" class="extype">List</span>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Option.html#scala.Option" name="scala.Option" id="scala.Option" class="extype">Option</a>[<span name="scredis.commands.KeyCommands.sort.R" class="extype">R</span>]]]</span></span><p class="shortcomment cmt">Sorts the elements of a list, set or sorted set.</p><div class="fullcomment"><div class="comment cmt"><p>Sorts the elements of a list, set or sorted set.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>key of list, set or sorted set to be sorted</p></dd><dt class="param">byOpt</dt><dd class="cmt"><p>optional pattern for sorting by external values, can also be "nosort" if
the sorting operation should be skipped (useful when only sorting to retrieve objects
with get). The * gets replaced by the values of the elements in the collection</p></dd><dt class="param">limitOpt</dt><dd class="cmt"><p>optional pair of numbers (offset, count) where offset specified the number of
elements to skip and count specifies the number of elements to return starting from offset</p></dd><dt class="param">get</dt><dd class="cmt"><p>list of patterns for retrieving objects stored in external keys. The * gets
replaced by the values of the elements in the collection</p></dd><dt class="param">desc</dt><dd class="cmt"><p>indicates whether elements should be sorted descendingly</p></dd><dt class="param">alpha</dt><dd class="cmt"><p>indicates whether elements should be sorted lexicographically</p></dd><dt>returns</dt><dd class="cmt"><p>the sorted list of elements, or the empty list if the key does not exist</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/KeyCommands.html" name="scredis.commands.KeyCommands" id="scredis.commands.KeyCommands" class="extype">KeyCommands</a></dd><dt>Since</dt><dd><p>1.0.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> whenever an error occurs</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.KeyCommands#sortAndStore" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="sortAndStore(key:String,targetKey:String,byOpt:Option[String],limitOpt:Option[(Long,Long)],get:Iterable[String],desc:Boolean,alpha:Boolean):scala.concurrent.Future[Long]"></a><a id="sortAndStore(String,String,Option[String],Option[(Long,Long)],Iterable[String],Boolean,Boolean):Future[Long]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#sortAndStore(key:String,targetKey:String,byOpt:Option[String],limitOpt:Option[(Long,Long)],get:Iterable[String],desc:Boolean,alpha:Boolean):scala.concurrent.Future[Long]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">sortAndStore</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="targetKey">targetKey: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="byOpt">byOpt: <a href="https://www.scala-lang.org/api/2.13.1/scala/Option.html#scala.Option" name="scala.Option" id="scala.Option" class="extype">Option</a>[<span name="scala.Predef.String" class="extype">String</span>] = <span class="symbol">None</span></span>, <span name="limitOpt">limitOpt: <a href="https://www.scala-lang.org/api/2.13.1/scala/Option.html#scala.Option" name="scala.Option" id="scala.Option" class="extype">Option</a>[(<a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a>, <a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a>)] = <span class="symbol">None</span></span>, <span name="get">get: <span name="scala.Iterable" class="extype">Iterable</span>[<span name="scala.Predef.String" class="extype">String</span>] = <span class="symbol">Nil</span></span>, <span name="desc">desc: <a href="https://www.scala-lang.org/api/2.13.1/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a> = <span class="symbol">false</span></span>, <span name="alpha">alpha: <a href="https://www.scala-lang.org/api/2.13.1/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a> = <span class="symbol">false</span></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a>]</span></span><p class="shortcomment cmt">Sorts the elements of a list, set or sorted set and then store the result.</p><div class="fullcomment"><div class="comment cmt"><p>Sorts the elements of a list, set or sorted set and then store the result.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>key of list, set or sorted set to be sorted</p></dd><dt class="param">targetKey</dt><dd class="cmt"><p>key of list, set or sorted set to be sorted</p></dd><dt class="param">byOpt</dt><dd class="cmt"><p>optional pattern for sorting by external values, can also be "nosort" if
the sorting operation should be skipped (useful when only sorting to retrieve objects
with get). The * gets replaced by the values of the elements in the collection</p></dd><dt class="param">limitOpt</dt><dd class="cmt"><p>optional pair of numbers (offset, count) where offset specified the
number of elements to skip and count specifies the number of elements to return starting
from offset</p></dd><dt class="param">get</dt><dd class="cmt"><p>list of patterns for retrieving objects stored in external keys. The * gets
replaced by the values of the elements in the collection</p></dd><dt class="param">desc</dt><dd class="cmt"><p>indicates whether elements should be sorted descendingly</p></dd><dt class="param">alpha</dt><dd class="cmt"><p>indicates whether elements should be sorted lexicographically</p></dd><dt>returns</dt><dd class="cmt"><p>the number of elements in the newly stored sorted collection</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/KeyCommands.html" name="scredis.commands.KeyCommands" id="scredis.commands.KeyCommands" class="extype">KeyCommands</a></dd><dt>Since</dt><dd><p>1.0.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> whenever an error occurs</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.StringCommands#strLen" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="strLen(key:String):scala.concurrent.Future[Long]"></a><a id="strLen(String):Future[Long]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#strLen(key:String):scala.concurrent.Future[Long]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">strLen</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a>]</span></span><p class="shortcomment cmt">Returns the length of the string value stored in a key.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the length of the string value stored in a key.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>target key</p></dd><dt>returns</dt><dd class="cmt"><p>the length of the string stored at key, or 0 when the key does not exist</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/StringCommands.html" name="scredis.commands.StringCommands" id="scredis.commands.StringCommands" class="extype">StringCommands</a></dd><dt>Since</dt><dd><p>2.2.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if the key contains a value of the wrong type</p></span></dd></dl></div></li><li class="indented0 " name="scala.AnyRef#synchronized" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="synchronized[T0](x$1:=&gt;T0):T0"></a><a id="synchronized[T0](=&gt;T0):T0"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#synchronized[T0](x$1:=&gt;T0):T0" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">synchronized</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="params">(<span name="arg0">arg0: =&gt; <span name="java.lang.AnyRef.synchronized.T0" class="extype">T0</span></span>)</span><span class="result">: <span name="java.lang.AnyRef.synchronized.T0" class="extype">T0</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div></li><li class="indented0 " name="scala.AnyRef#toString" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="toString():String"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#toString():String" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">toString</span><span class="params">()</span><span class="result">: <span name="java.lang.String" class="extype">String</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="scredis.commands.KeyCommands#ttl" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="ttl(key:String):scala.concurrent.Future[Either[Boolean,Int]]"></a><a id="ttl(String):Future[Either[Boolean,Int]]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#ttl(key:String):scala.concurrent.Future[Either[Boolean,Int]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">ttl</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="scala.Either" class="extype">Either</span>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a>, <a href="https://www.scala-lang.org/api/2.13.1/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a>]]</span></span><p class="shortcomment cmt">Gets the time to live for a key in seconds.</p><div class="fullcomment"><div class="comment cmt"><p>Gets the time to live for a key in seconds.</p><pre>result <span class="kw">match</span> {
  <span class="kw">case</span> Left(<span class="kw">false</span>) <span class="kw">=&gt;</span> <span class="cmt">// key does not exist</span>
  <span class="kw">case</span> Left(<span class="kw">true</span>) <span class="kw">=&gt;</span> <span class="cmt">// key exists but has no associated expire</span>
  <span class="kw">case</span> Right(ttl) <span class="kw">=&gt;</span>
}</pre></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>the target key</p></dd><dt>returns</dt><dd class="cmt"><p><code>Right(ttl)</code> where ttl is the time-to-live in seconds for specified key,
<code>Left(false)</code> if key does not exist or <code>Left(true)</code> if key exists but has no associated
expire</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/KeyCommands.html" name="scredis.commands.KeyCommands" id="scredis.commands.KeyCommands" class="extype">KeyCommands</a></dd><dt>Since</dt><dd><p>1.0.0</p></dd><dt>Note</dt><dd><span class="cmt"><p>For <code>Redis</code> version &lt;= 2.8.x, <code>Left(false)</code> will be returned when the key does not
exists and when it exists but has no associated expire (<code>Redis</code> returns the same error code
for both cases). In other words, you can simply check the following</p><pre>result <span class="kw">match</span> {
  <span class="kw">case</span> Left(_) <span class="kw">=&gt;</span>
  <span class="kw">case</span> Right(ttl) <span class="kw">=&gt;</span>
}</pre></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.KeyCommands#type" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="type(key:String):scala.concurrent.Future[Option[scredis.Type]]"></a><a id="type(String):Future[Option[Type]]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#type(key:String):scala.concurrent.Future[Option[scredis.Type]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">type</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Option.html#scala.Option" name="scala.Option" id="scala.Option" class="extype">Option</a>[<a href="package$$Type.html" name="scredis.Type" id="scredis.Type" class="extype">Type</a>]]</span></span><p class="shortcomment cmt">Determine the type stored at key.</p><div class="fullcomment"><div class="comment cmt"><p>Determine the type stored at key.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>key for which the type should be returned</p></dd><dt>returns</dt><dd class="cmt"><p>type of key, or <code>None</code> if key does not exist</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/KeyCommands.html" name="scredis.commands.KeyCommands" id="scredis.commands.KeyCommands" class="extype">KeyCommands</a></dd><dt>Since</dt><dd><p>1.0.0</p></dd><dt>Note</dt><dd><span class="cmt"><p>This method needs to be called as follows:</p><pre>client.`<span class="kw">type</span>`(key)</pre></span></dd></dl></div></li><li class="indented0 " name="scala.AnyRef#wait" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="wait():Unit"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#wait():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">wait</span><span class="params">()</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">classOf[java.lang.InterruptedException]</span></span>)</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#wait" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="wait(x$1:Long,x$2:Int):Unit"></a><a id="wait(Long,Int):Unit"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#wait(x$1:Long,x$2:Int):Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">wait</span><span class="params">(<span name="arg0">arg0: <a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a></span>, <span name="arg1">arg1: <a href="https://www.scala-lang.org/api/2.13.1/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">classOf[java.lang.InterruptedException]</span></span>)</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#wait" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="wait(x$1:Long):Unit"></a><a id="wait(Long):Unit"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#wait(x$1:Long):Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">wait</span><span class="params">(<span name="arg0">arg0: <a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">classOf[java.lang.InterruptedException]</span></span>)</span> <span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="scredis.commands.SortedSetCommands#zAdd" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="zAdd[W](key:String,members:Map[W,scredis.Score])(implicitevidence$2:scredis.serialization.Writer[W]):scala.concurrent.Future[Long]"></a><a id="zAdd[W](String,Map[W,Score])(Writer[W]):Future[Long]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#zAdd[W](key:String,members:Map[W,scredis.Score])(implicitevidence$2:scredis.serialization.Writer[W]):scala.concurrent.Future[Long]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">zAdd</span><span class="tparams">[<span name="W">W</span>]</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="members">members: <span name="scala.Predef.Map" class="extype">Map</span>[<span name="scredis.commands.SortedSetCommands.zAdd.W" class="extype">W</span>, <a href="package$$Score.html" name="scredis.Score" id="scredis.Score" class="extype">Score</a>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Writer.html" name="scredis.serialization.Writer" id="scredis.serialization.Writer" class="extype">Writer</a>[<span name="scredis.commands.SortedSetCommands.zAdd.W" class="extype">W</span>]</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a>]</span></span><p class="shortcomment cmt">Adds one or more members to a sorted set, or update its score if it already exists.</p><div class="fullcomment"><div class="comment cmt"><p>Adds one or more members to a sorted set, or update its score if it already exists.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>sorted set key</p></dd><dt class="param">members</dt><dd class="cmt"><p>member-score pairs to be added</p></dd><dt>returns</dt><dd class="cmt"><p>the number of elements added to the sorted sets, not including elements already
existing for which the score was updated</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/SortedSetCommands.html" name="scredis.commands.SortedSetCommands" id="scredis.commands.SortedSetCommands" class="extype">SortedSetCommands</a></dd><dt>Since</dt><dd><p>2.4</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if key contains a value that is not a sorted set</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>If a specified member is already a member of the sorted set, the score is updated and
the element reinserted at the right position to ensure the correct ordering.</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.SortedSetCommands#zAdd" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="zAdd[W](key:String,member:W,score:scredis.Score)(implicitevidence$1:scredis.serialization.Writer[W]):scala.concurrent.Future[Boolean]"></a><a id="zAdd[W](String,W,Score)(Writer[W]):Future[Boolean]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#zAdd[W](key:String,member:W,score:scredis.Score)(implicitevidence$1:scredis.serialization.Writer[W]):scala.concurrent.Future[Boolean]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">zAdd</span><span class="tparams">[<span name="W">W</span>]</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="member">member: <span name="scredis.commands.SortedSetCommands.zAdd.W" class="extype">W</span></span>, <span name="score">score: <a href="package$$Score.html" name="scredis.Score" id="scredis.Score" class="extype">Score</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Writer.html" name="scredis.serialization.Writer" id="scredis.serialization.Writer" class="extype">Writer</a>[<span name="scredis.commands.SortedSetCommands.zAdd.W" class="extype">W</span>]</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a>]</span></span><p class="shortcomment cmt">Adds a member to a sorted set, or update its score if it already exists.</p><div class="fullcomment"><div class="comment cmt"><p>Adds a member to a sorted set, or update its score if it already exists.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>sorted set key</p></dd><dt class="param">member</dt><dd class="cmt"><p>member to add</p></dd><dt class="param">score</dt><dd class="cmt"><p>score of the member to add</p></dd><dt>returns</dt><dd class="cmt"><p><b>true</b> if the member was added, or <b>false</b> if the member already exists</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/SortedSetCommands.html" name="scredis.commands.SortedSetCommands" id="scredis.commands.SortedSetCommands" class="extype">SortedSetCommands</a></dd><dt>Since</dt><dd><p>1.2.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if key contains a value that is not a sorted set</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>If a specified member is already a member of the sorted set, the score is updated and
the element reinserted at the right position to ensure the correct ordering.</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.SortedSetCommands#zCard" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="zCard(key:String):scala.concurrent.Future[Long]"></a><a id="zCard(String):Future[Long]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#zCard(key:String):scala.concurrent.Future[Long]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">zCard</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a>]</span></span><p class="shortcomment cmt">Returns the number of members in a sorted set.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the number of members in a sorted set.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>sorted set key</p></dd><dt>returns</dt><dd class="cmt"><p>the cardinality (number of elements) of the sorted set, or 0 if key does not exist</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/SortedSetCommands.html" name="scredis.commands.SortedSetCommands" id="scredis.commands.SortedSetCommands" class="extype">SortedSetCommands</a></dd><dt>Since</dt><dd><p>1.2.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if key contains a value that is not a sorted set</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.SortedSetCommands#zCount" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="zCount(key:String,min:scredis.ScoreLimit,max:scredis.ScoreLimit):scala.concurrent.Future[Long]"></a><a id="zCount(String,ScoreLimit,ScoreLimit):Future[Long]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#zCount(key:String,min:scredis.ScoreLimit,max:scredis.ScoreLimit):scala.concurrent.Future[Long]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">zCount</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="min">min: <a href="package$$ScoreLimit.html" name="scredis.ScoreLimit" id="scredis.ScoreLimit" class="extype">ScoreLimit</a></span>, <span name="max">max: <a href="package$$ScoreLimit.html" name="scredis.ScoreLimit" id="scredis.ScoreLimit" class="extype">ScoreLimit</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a>]</span></span><p class="shortcomment cmt">Returns the number of elements of a sorted set belonging to a given score range.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the number of elements of a sorted set belonging to a given score range.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>sorted set key</p></dd><dt class="param">min</dt><dd class="cmt"><p>score lower bound</p></dd><dt class="param">max</dt><dd class="cmt"><p>score upper bound</p></dd><dt>returns</dt><dd class="cmt"><p>the number of elements in the specified score range</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/SortedSetCommands.html" name="scredis.commands.SortedSetCommands" id="scredis.commands.SortedSetCommands" class="extype">SortedSetCommands</a></dd><dt>Since</dt><dd><p>2.0.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if key contains a value that is not a sorted set</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.SortedSetCommands#zIncrBy" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="zIncrBy[W](key:String,member:W,increment:Double)(implicitevidence$3:scredis.serialization.Writer[W]):scala.concurrent.Future[Double]"></a><a id="zIncrBy[W](String,W,Double)(Writer[W]):Future[Double]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#zIncrBy[W](key:String,member:W,increment:Double)(implicitevidence$3:scredis.serialization.Writer[W]):scala.concurrent.Future[Double]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">zIncrBy</span><span class="tparams">[<span name="W">W</span>]</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="member">member: <span name="scredis.commands.SortedSetCommands.zIncrBy.W" class="extype">W</span></span>, <span name="increment">increment: <a href="https://www.scala-lang.org/api/2.13.1/scala/Double.html#scala.Double" name="scala.Double" id="scala.Double" class="extype">Double</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Writer.html" name="scredis.serialization.Writer" id="scredis.serialization.Writer" class="extype">Writer</a>[<span name="scredis.commands.SortedSetCommands.zIncrBy.W" class="extype">W</span>]</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Double.html#scala.Double" name="scala.Double" id="scala.Double" class="extype">Double</a>]</span></span><p class="shortcomment cmt">Increments the score of a member in a sorted set.</p><div class="fullcomment"><div class="comment cmt"><p>Increments the score of a member in a sorted set.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>sorted set key</p></dd><dt class="param">member</dt><dd class="cmt"><p>member whose score needs to be incremented</p></dd><dt class="param">increment</dt><dd class="cmt"><p>the increment</p></dd><dt>returns</dt><dd class="cmt"><p>the new score of member</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/SortedSetCommands.html" name="scredis.commands.SortedSetCommands" id="scredis.commands.SortedSetCommands" class="extype">SortedSetCommands</a></dd><dt>Since</dt><dd><p>1.2.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if key contains a value that is not a sorted set</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.SortedSetCommands#zInterStore" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="zInterStore(destKey:String,keys:Seq[String],aggregate:scredis.Aggregate):scala.concurrent.Future[Long]"></a><a id="zInterStore(String,Seq[String],Aggregate):Future[Long]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#zInterStore(destKey:String,keys:Seq[String],aggregate:scredis.Aggregate):scala.concurrent.Future[Long]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">zInterStore</span><span class="params">(<span name="destKey">destKey: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="keys">keys: <span name="scala.Seq" class="extype">Seq</span>[<span name="scala.Predef.String" class="extype">String</span>]</span>, <span name="aggregate">aggregate: <a href="package$$Aggregate.html" name="scredis.Aggregate" id="scredis.Aggregate" class="extype">Aggregate</a> = <span class="symbol"><span class="name"><a href="index.html">scredis.Aggregate.Sum</a></span></span></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a>]</span></span><p class="shortcomment cmt">Intersects multiple sorted sets and stores the resulting sorted set in a new key.</p><div class="fullcomment"><div class="comment cmt"><p>Intersects multiple sorted sets and stores the resulting sorted set in a new key.
</p></div><dl class="paramcmts block"><dt class="param">destKey</dt><dd class="cmt"><p>sorted set key</p></dd><dt class="param">keys</dt><dd class="cmt"><p>keys of sorted sets to intersect</p></dd><dt class="param">aggregate</dt><dd class="cmt"><p>aggregation function (default is Sum)</p></dd><dt>returns</dt><dd class="cmt"><p>the number of elements in the resulting sorted set stored at destKey</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/SortedSetCommands.html" name="scredis.commands.SortedSetCommands" id="scredis.commands.SortedSetCommands" class="extype">SortedSetCommands</a></dd><dt>Since</dt><dd><p>2.0.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if key contains a value that is not a sorted set</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.SortedSetCommands#zInterStoreWeighted" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="zInterStoreWeighted(destKey:String,keysWeightPairs:Map[String,Double],aggregate:scredis.Aggregate):scala.concurrent.Future[Long]"></a><a id="zInterStoreWeighted(String,Map[String,Double],Aggregate):Future[Long]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#zInterStoreWeighted(destKey:String,keysWeightPairs:Map[String,Double],aggregate:scredis.Aggregate):scala.concurrent.Future[Long]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">zInterStoreWeighted</span><span class="params">(<span name="destKey">destKey: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="keysWeightPairs">keysWeightPairs: <span name="scala.Predef.Map" class="extype">Map</span>[<span name="scala.Predef.String" class="extype">String</span>, <a href="https://www.scala-lang.org/api/2.13.1/scala/Double.html#scala.Double" name="scala.Double" id="scala.Double" class="extype">Double</a>]</span>, <span name="aggregate">aggregate: <a href="package$$Aggregate.html" name="scredis.Aggregate" id="scredis.Aggregate" class="extype">Aggregate</a> = <span class="symbol"><span class="name"><a href="index.html">scredis.Aggregate.Sum</a></span></span></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a>]</span></span><p class="shortcomment cmt">Intersects multiple sorted sets and stores the resulting sorted set in a new key.</p><div class="fullcomment"><div class="comment cmt"><p>Intersects multiple sorted sets and stores the resulting sorted set in a new key.
</p></div><dl class="paramcmts block"><dt class="param">destKey</dt><dd class="cmt"><p>sorted set key</p></dd><dt class="param">keysWeightPairs</dt><dd class="cmt"><p>key to weight pairs</p></dd><dt class="param">aggregate</dt><dd class="cmt"><p>aggregation function (default is Sum)</p></dd><dt>returns</dt><dd class="cmt"><p>the number of elements in the resulting sorted set stored at destKey</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/SortedSetCommands.html" name="scredis.commands.SortedSetCommands" id="scredis.commands.SortedSetCommands" class="extype">SortedSetCommands</a></dd><dt>Since</dt><dd><p>2.0.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if key contains a value that is not a sorted set</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.SortedSetCommands#zLexCount" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="zLexCount(key:String,min:scredis.LexicalScoreLimit,max:scredis.LexicalScoreLimit):scala.concurrent.Future[Long]"></a><a id="zLexCount(String,LexicalScoreLimit,LexicalScoreLimit):Future[Long]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#zLexCount(key:String,min:scredis.LexicalScoreLimit,max:scredis.LexicalScoreLimit):scala.concurrent.Future[Long]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">zLexCount</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="min">min: <a href="package$$LexicalScoreLimit.html" name="scredis.LexicalScoreLimit" id="scredis.LexicalScoreLimit" class="extype">LexicalScoreLimit</a></span>, <span name="max">max: <a href="package$$LexicalScoreLimit.html" name="scredis.LexicalScoreLimit" id="scredis.LexicalScoreLimit" class="extype">LexicalScoreLimit</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a>]</span></span><p class="shortcomment cmt">Returns the number of elements of a sorted set belonging to a given lexical score range.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the number of elements of a sorted set belonging to a given lexical score range.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>sorted set key</p></dd><dt class="param">min</dt><dd class="cmt"><p>lexical score lower bound</p></dd><dt class="param">max</dt><dd class="cmt"><p>lexical score upper bound</p></dd><dt>returns</dt><dd class="cmt"><p>the number of elements in the specified lexical score range</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/SortedSetCommands.html" name="scredis.commands.SortedSetCommands" id="scredis.commands.SortedSetCommands" class="extype">SortedSetCommands</a></dd><dt>Since</dt><dd><p>2.8.9</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if key contains a value that is not a sorted set</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>Lexical ordering only applies when all the elements in a sorted set are inserted
with the same score</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.SortedSetCommands#zRange" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="zRange[R](key:String,start:Long,stop:Long)(implicitevidence$4:scredis.serialization.Reader[R]):scala.concurrent.Future[scredis.util.LinkedHashSet[R]]"></a><a id="zRange[R](String,Long,Long)(Reader[R]):Future[LinkedHashSet[R]]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#zRange[R](key:String,start:Long,stop:Long)(implicitevidence$4:scredis.serialization.Reader[R]):scala.concurrent.Future[scredis.util.LinkedHashSet[R]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">zRange</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="start">start: <a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a> = <span class="symbol">0</span></span>, <span name="stop">stop: <a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a> = <span class="symbol">-1</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Reader.html" name="scredis.serialization.Reader" id="scredis.serialization.Reader" class="extype">Reader</a>[<span name="scredis.commands.SortedSetCommands.zRange.R" class="extype">R</span>]</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="util/LinkedHashSet.html" name="scredis.util.LinkedHashSet" id="scredis.util.LinkedHashSet" class="extype">LinkedHashSet</a>[<span name="scredis.commands.SortedSetCommands.zRange.R" class="extype">R</span>]]</span></span><p class="shortcomment cmt">Returns a range of members in a sorted set, by index.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a range of members in a sorted set, by index.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>sorted set key</p></dd><dt class="param">start</dt><dd class="cmt"><p>start offset (inclusive)</p></dd><dt class="param">stop</dt><dd class="cmt"><p>stop offset (inclusive)</p></dd><dt>returns</dt><dd class="cmt"><p>the set of ascendingly ordered elements in the specified range, or the empty set if
key does not exist</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/SortedSetCommands.html" name="scredis.commands.SortedSetCommands" id="scredis.commands.SortedSetCommands" class="extype">SortedSetCommands</a></dd><dt>Since</dt><dd><p>1.2.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if key contains a value that is not a sorted set</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>Both start and stop are zero-based indexes, where 0 is the first element, 1 is the next
element and so on. They can also be negative numbers indicating offsets from the end of the
sorted set, with -1 being the last element of the sorted set, -2 the penultimate element and
so on. Out of range indexes will not produce an error. If start is larger than the largest
index in the sorted set, or <code>start</code> &gt; <code>end</code>, an empty list is returned. If <code>end</code> is larger
than the end of the sorted set Redis will treat it like it is the last element of the
sorted set. The indexes are inclusive.</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.SortedSetCommands#zRangeByLex" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="zRangeByLex[R](key:String,min:scredis.LexicalScoreLimit,max:scredis.LexicalScoreLimit,limitOpt:Option[(Long,Int)])(implicitevidence$6:scredis.serialization.Reader[R]):scala.concurrent.Future[scredis.util.LinkedHashSet[R]]"></a><a id="zRangeByLex[R](String,LexicalScoreLimit,LexicalScoreLimit,Option[(Long,Int)])(Reader[R]):Future[LinkedHashSet[R]]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#zRangeByLex[R](key:String,min:scredis.LexicalScoreLimit,max:scredis.LexicalScoreLimit,limitOpt:Option[(Long,Int)])(implicitevidence$6:scredis.serialization.Reader[R]):scala.concurrent.Future[scredis.util.LinkedHashSet[R]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">zRangeByLex</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="min">min: <a href="package$$LexicalScoreLimit.html" name="scredis.LexicalScoreLimit" id="scredis.LexicalScoreLimit" class="extype">LexicalScoreLimit</a></span>, <span name="max">max: <a href="package$$LexicalScoreLimit.html" name="scredis.LexicalScoreLimit" id="scredis.LexicalScoreLimit" class="extype">LexicalScoreLimit</a></span>, <span name="limitOpt">limitOpt: <a href="https://www.scala-lang.org/api/2.13.1/scala/Option.html#scala.Option" name="scala.Option" id="scala.Option" class="extype">Option</a>[(<a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a>, <a href="https://www.scala-lang.org/api/2.13.1/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a>)] = <span class="symbol">None</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Reader.html" name="scredis.serialization.Reader" id="scredis.serialization.Reader" class="extype">Reader</a>[<span name="scredis.commands.SortedSetCommands.zRangeByLex.R" class="extype">R</span>]</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="util/LinkedHashSet.html" name="scredis.util.LinkedHashSet" id="scredis.util.LinkedHashSet" class="extype">LinkedHashSet</a>[<span name="scredis.commands.SortedSetCommands.zRangeByLex.R" class="extype">R</span>]]</span></span><p class="shortcomment cmt">Returns a range of members in a sorted set, by lexical score.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a range of members in a sorted set, by lexical score.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>sorted set key</p></dd><dt class="param">min</dt><dd class="cmt"><p>lexical score lower bound</p></dd><dt class="param">max</dt><dd class="cmt"><p>lexical score upper bound</p></dd><dt class="param">limitOpt</dt><dd class="cmt"><p>optional offset and count pair used to limit the number of matching elements</p></dd><dt>returns</dt><dd class="cmt"><p>the set of ascendingly ordered elements in the specified lexical range, or the empty
set if key does not exist</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/SortedSetCommands.html" name="scredis.commands.SortedSetCommands" id="scredis.commands.SortedSetCommands" class="extype">SortedSetCommands</a></dd><dt>Since</dt><dd><p>2.8.9</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if key contains a value that is not a sorted set</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>Lexical ordering only applies when all the elements in a sorted set are inserted
with the same score</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.SortedSetCommands#zRangeByScore" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="zRangeByScore[R](key:String,min:scredis.ScoreLimit,max:scredis.ScoreLimit,limitOpt:Option[(Long,Int)])(implicitevidence$7:scredis.serialization.Reader[R]):scala.concurrent.Future[scredis.util.LinkedHashSet[R]]"></a><a id="zRangeByScore[R](String,ScoreLimit,ScoreLimit,Option[(Long,Int)])(Reader[R]):Future[LinkedHashSet[R]]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#zRangeByScore[R](key:String,min:scredis.ScoreLimit,max:scredis.ScoreLimit,limitOpt:Option[(Long,Int)])(implicitevidence$7:scredis.serialization.Reader[R]):scala.concurrent.Future[scredis.util.LinkedHashSet[R]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">zRangeByScore</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="min">min: <a href="package$$ScoreLimit.html" name="scredis.ScoreLimit" id="scredis.ScoreLimit" class="extype">ScoreLimit</a></span>, <span name="max">max: <a href="package$$ScoreLimit.html" name="scredis.ScoreLimit" id="scredis.ScoreLimit" class="extype">ScoreLimit</a></span>, <span name="limitOpt">limitOpt: <a href="https://www.scala-lang.org/api/2.13.1/scala/Option.html#scala.Option" name="scala.Option" id="scala.Option" class="extype">Option</a>[(<a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a>, <a href="https://www.scala-lang.org/api/2.13.1/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a>)] = <span class="symbol">None</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Reader.html" name="scredis.serialization.Reader" id="scredis.serialization.Reader" class="extype">Reader</a>[<span name="scredis.commands.SortedSetCommands.zRangeByScore.R" class="extype">R</span>]</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="util/LinkedHashSet.html" name="scredis.util.LinkedHashSet" id="scredis.util.LinkedHashSet" class="extype">LinkedHashSet</a>[<span name="scredis.commands.SortedSetCommands.zRangeByScore.R" class="extype">R</span>]]</span></span><p class="shortcomment cmt">Returns a range of members in a sorted set, by score.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a range of members in a sorted set, by score.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>sorted set key</p></dd><dt class="param">min</dt><dd class="cmt"><p>score lower bound</p></dd><dt class="param">max</dt><dd class="cmt"><p>score upper bound</p></dd><dt class="param">limitOpt</dt><dd class="cmt"><p>optional offset and count pair used to limit the number of matching elements</p></dd><dt>returns</dt><dd class="cmt"><p>the set of ascendingly ordered elements in the specified score range, or the empty set
if key does not exist</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/SortedSetCommands.html" name="scredis.commands.SortedSetCommands" id="scredis.commands.SortedSetCommands" class="extype">SortedSetCommands</a></dd><dt>Since</dt><dd><p>2.2.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if key contains a value that is not a sorted set</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>The elements having the same score are returned in lexicographical order (this follows
from a property of the sorted set implementation in Redis and does not involve further
computation).</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.SortedSetCommands#zRangeByScoreWithScores" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="zRangeByScoreWithScores[R](key:String,min:scredis.ScoreLimit,max:scredis.ScoreLimit,limitOpt:Option[(Long,Int)])(implicitevidence$8:scredis.serialization.Reader[R]):scala.concurrent.Future[scredis.util.LinkedHashSet[(R,scredis.Score)]]"></a><a id="zRangeByScoreWithScores[R](String,ScoreLimit,ScoreLimit,Option[(Long,Int)])(Reader[R]):Future[LinkedHashSet[(R,Score)]]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#zRangeByScoreWithScores[R](key:String,min:scredis.ScoreLimit,max:scredis.ScoreLimit,limitOpt:Option[(Long,Int)])(implicitevidence$8:scredis.serialization.Reader[R]):scala.concurrent.Future[scredis.util.LinkedHashSet[(R,scredis.Score)]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">zRangeByScoreWithScores</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="min">min: <a href="package$$ScoreLimit.html" name="scredis.ScoreLimit" id="scredis.ScoreLimit" class="extype">ScoreLimit</a></span>, <span name="max">max: <a href="package$$ScoreLimit.html" name="scredis.ScoreLimit" id="scredis.ScoreLimit" class="extype">ScoreLimit</a></span>, <span name="limitOpt">limitOpt: <a href="https://www.scala-lang.org/api/2.13.1/scala/Option.html#scala.Option" name="scala.Option" id="scala.Option" class="extype">Option</a>[(<a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a>, <a href="https://www.scala-lang.org/api/2.13.1/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a>)] = <span class="symbol">None</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Reader.html" name="scredis.serialization.Reader" id="scredis.serialization.Reader" class="extype">Reader</a>[<span name="scredis.commands.SortedSetCommands.zRangeByScoreWithScores.R" class="extype">R</span>]</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="util/LinkedHashSet.html" name="scredis.util.LinkedHashSet" id="scredis.util.LinkedHashSet" class="extype">LinkedHashSet</a>[(<span name="scredis.commands.SortedSetCommands.zRangeByScoreWithScores.R" class="extype">R</span>, <a href="package$$Score.html" name="scredis.Score" id="scredis.Score" class="extype">Score</a>)]]</span></span><p class="shortcomment cmt">Returns a range of members with associated scores in a sorted set, by score.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a range of members with associated scores in a sorted set, by score.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>sorted set key</p></dd><dt class="param">min</dt><dd class="cmt"><p>score lower bound</p></dd><dt class="param">max</dt><dd class="cmt"><p>score upper bound</p></dd><dt class="param">limitOpt</dt><dd class="cmt"><p>optional offset and count pair used to limit the number of matching elements</p></dd><dt>returns</dt><dd class="cmt"><p>the set of ascendingly ordered element-score pairs in the specified score range, or
the empty set if key does not exist</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/SortedSetCommands.html" name="scredis.commands.SortedSetCommands" id="scredis.commands.SortedSetCommands" class="extype">SortedSetCommands</a></dd><dt>Since</dt><dd><p>2.0.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if key contains a value that is not a sorted set</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>The elements having the same score are returned in lexicographical order (this follows
from a property of the sorted set implementation in Redis and does not involve further
computation).</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.SortedSetCommands#zRangeWithScores" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="zRangeWithScores[R](key:String,start:Long,stop:Long)(implicitevidence$5:scredis.serialization.Reader[R]):scala.concurrent.Future[scredis.util.LinkedHashSet[(R,scredis.Score)]]"></a><a id="zRangeWithScores[R](String,Long,Long)(Reader[R]):Future[LinkedHashSet[(R,Score)]]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#zRangeWithScores[R](key:String,start:Long,stop:Long)(implicitevidence$5:scredis.serialization.Reader[R]):scala.concurrent.Future[scredis.util.LinkedHashSet[(R,scredis.Score)]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">zRangeWithScores</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="start">start: <a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a> = <span class="symbol">0</span></span>, <span name="stop">stop: <a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a> = <span class="symbol">-1</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Reader.html" name="scredis.serialization.Reader" id="scredis.serialization.Reader" class="extype">Reader</a>[<span name="scredis.commands.SortedSetCommands.zRangeWithScores.R" class="extype">R</span>]</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="util/LinkedHashSet.html" name="scredis.util.LinkedHashSet" id="scredis.util.LinkedHashSet" class="extype">LinkedHashSet</a>[(<span name="scredis.commands.SortedSetCommands.zRangeWithScores.R" class="extype">R</span>, <a href="package$$Score.html" name="scredis.Score" id="scredis.Score" class="extype">Score</a>)]]</span></span><p class="shortcomment cmt">Returns a range of members with associated scores in a sorted set, by index.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a range of members with associated scores in a sorted set, by index.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>sorted set key</p></dd><dt class="param">start</dt><dd class="cmt"><p>start offset (inclusive)</p></dd><dt class="param">stop</dt><dd class="cmt"><p>end offset (inclusive)</p></dd><dt>returns</dt><dd class="cmt"><p>the set of ascendingly ordered elements-score pairs in the specified range, or the
empty set if key does not exist</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/SortedSetCommands.html" name="scredis.commands.SortedSetCommands" id="scredis.commands.SortedSetCommands" class="extype">SortedSetCommands</a></dd><dt>Since</dt><dd><p>1.2.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if key contains a value that is not a sorted set</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>Both start and stop are zero-based indexes, where 0 is the first element, 1 is the next
element and so on. They can also be negative numbers indicating offsets from the end of the
sorted set, with -1 being the last element of the sorted set, -2 the penultimate element and
so on. Out of range indexes will not produce an error. If start is larger than the largest
index in the sorted set, or <code>start</code> &gt; <code>end</code>, an empty list is returned. If <code>end</code> is larger
than the end of the sorted set Redis will treat it like it is the last element of the
sorted set. The indexes are inclusive.</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.SortedSetCommands#zRank" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="zRank[W](key:String,member:W)(implicitevidence$9:scredis.serialization.Writer[W]):scala.concurrent.Future[Option[Long]]"></a><a id="zRank[W](String,W)(Writer[W]):Future[Option[Long]]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#zRank[W](key:String,member:W)(implicitevidence$9:scredis.serialization.Writer[W]):scala.concurrent.Future[Option[Long]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">zRank</span><span class="tparams">[<span name="W">W</span>]</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="member">member: <span name="scredis.commands.SortedSetCommands.zRank.W" class="extype">W</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Writer.html" name="scredis.serialization.Writer" id="scredis.serialization.Writer" class="extype">Writer</a>[<span name="scredis.commands.SortedSetCommands.zRank.W" class="extype">W</span>]</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Option.html#scala.Option" name="scala.Option" id="scala.Option" class="extype">Option</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a>]]</span></span><p class="shortcomment cmt">Determines the index of a member in a sorted set.</p><div class="fullcomment"><div class="comment cmt"><p>Determines the index of a member in a sorted set.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>sorted set key</p></dd><dt class="param">member</dt><dd class="cmt"><p>the value</p></dd><dt>returns</dt><dd class="cmt"><p>the rank or index of the member, or <code>None</code> if the member is not in the set or the key
does not exist</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/SortedSetCommands.html" name="scredis.commands.SortedSetCommands" id="scredis.commands.SortedSetCommands" class="extype">SortedSetCommands</a></dd><dt>Since</dt><dd><p>2.0.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if key contains a value that is not a sorted set</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.SortedSetCommands#zRem" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="zRem[W](key:String,members:W*)(implicitevidence$10:scredis.serialization.Writer[W]):scala.concurrent.Future[Long]"></a><a id="zRem[W](String,W*)(Writer[W]):Future[Long]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#zRem[W](key:String,members:W*)(implicitevidence$10:scredis.serialization.Writer[W]):scala.concurrent.Future[Long]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">zRem</span><span class="tparams">[<span name="W">W</span>]</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="members">members: <span name="scredis.commands.SortedSetCommands.zRem.W" class="extype">W</span>*</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Writer.html" name="scredis.serialization.Writer" id="scredis.serialization.Writer" class="extype">Writer</a>[<span name="scredis.commands.SortedSetCommands.zRem.W" class="extype">W</span>]</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a>]</span></span><p class="shortcomment cmt">Removes one or more members from a sorted set.</p><div class="fullcomment"><div class="comment cmt"><p>Removes one or more members from a sorted set.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>sorted set key</p></dd><dt class="param">members</dt><dd class="cmt"><p>additional values to be removed (only works with Redis &gt;= 2.4)</p></dd><dt>returns</dt><dd class="cmt"><p>the number of members removed from the sorted set, not including non existing members</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/SortedSetCommands.html" name="scredis.commands.SortedSetCommands" id="scredis.commands.SortedSetCommands" class="extype">SortedSetCommands</a></dd><dt>Since</dt><dd><p>2.0.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if key contains a value that is not a sorted set</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>Redis versions older than 2.4 can only remove one value per call.</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.SortedSetCommands#zRemRangeByLex" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="zRemRangeByLex(key:String,min:scredis.LexicalScoreLimit,max:scredis.LexicalScoreLimit):scala.concurrent.Future[Long]"></a><a id="zRemRangeByLex(String,LexicalScoreLimit,LexicalScoreLimit):Future[Long]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#zRemRangeByLex(key:String,min:scredis.LexicalScoreLimit,max:scredis.LexicalScoreLimit):scala.concurrent.Future[Long]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">zRemRangeByLex</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="min">min: <a href="package$$LexicalScoreLimit.html" name="scredis.LexicalScoreLimit" id="scredis.LexicalScoreLimit" class="extype">LexicalScoreLimit</a></span>, <span name="max">max: <a href="package$$LexicalScoreLimit.html" name="scredis.LexicalScoreLimit" id="scredis.LexicalScoreLimit" class="extype">LexicalScoreLimit</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a>]</span></span><p class="shortcomment cmt">Removes all members in a sorted set within the given lexical range.</p><div class="fullcomment"><div class="comment cmt"><p>Removes all members in a sorted set within the given lexical range.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>sorted set key</p></dd><dt class="param">min</dt><dd class="cmt"><p>lexical score lower bound</p></dd><dt class="param">max</dt><dd class="cmt"><p>lexical score upper bound</p></dd><dt>returns</dt><dd class="cmt"><p>the number of removed elements</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/SortedSetCommands.html" name="scredis.commands.SortedSetCommands" id="scredis.commands.SortedSetCommands" class="extype">SortedSetCommands</a></dd><dt>Since</dt><dd><p>2.8.9</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if key contains a value that is not a sorted set</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>Lexical ordering only applies when all the elements in a sorted set are inserted
with the same score</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.SortedSetCommands#zRemRangeByRank" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="zRemRangeByRank(key:String,start:Long,stop:Long):scala.concurrent.Future[Long]"></a><a id="zRemRangeByRank(String,Long,Long):Future[Long]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#zRemRangeByRank(key:String,start:Long,stop:Long):scala.concurrent.Future[Long]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">zRemRangeByRank</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="start">start: <a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a></span>, <span name="stop">stop: <a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a>]</span></span><p class="shortcomment cmt">Removes all members in a sorted set within the given indexes.</p><div class="fullcomment"><div class="comment cmt"><p>Removes all members in a sorted set within the given indexes.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>sorted set key</p></dd><dt class="param">start</dt><dd class="cmt"><p>the start offset or index (inclusive)</p></dd><dt class="param">stop</dt><dd class="cmt"><p>the stop offset or index (inclusive)</p></dd><dt>returns</dt><dd class="cmt"><p>the number of members removed</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/SortedSetCommands.html" name="scredis.commands.SortedSetCommands" id="scredis.commands.SortedSetCommands" class="extype">SortedSetCommands</a></dd><dt>Since</dt><dd><p>2.0.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if key contains a value that is not a sorted set</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>Both start and stop are zero-based inclusive indexes with 0 being the element with the
lowest score. These indexes can be negative numbers, where they indicate offsets starting at
the element with the highest score. For example: -1 is the element with the highest score, -2
the element with the second highest score and so forth.</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.SortedSetCommands#zRemRangeByScore" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="zRemRangeByScore(key:String,min:scredis.ScoreLimit,max:scredis.ScoreLimit):scala.concurrent.Future[Long]"></a><a id="zRemRangeByScore(String,ScoreLimit,ScoreLimit):Future[Long]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#zRemRangeByScore(key:String,min:scredis.ScoreLimit,max:scredis.ScoreLimit):scala.concurrent.Future[Long]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">zRemRangeByScore</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="min">min: <a href="package$$ScoreLimit.html" name="scredis.ScoreLimit" id="scredis.ScoreLimit" class="extype">ScoreLimit</a></span>, <span name="max">max: <a href="package$$ScoreLimit.html" name="scredis.ScoreLimit" id="scredis.ScoreLimit" class="extype">ScoreLimit</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a>]</span></span><p class="shortcomment cmt">Removes all members in a sorted set within the given scores range.</p><div class="fullcomment"><div class="comment cmt"><p>Removes all members in a sorted set within the given scores range.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>sorted set key</p></dd><dt class="param">min</dt><dd class="cmt"><p>score lower bound</p></dd><dt class="param">max</dt><dd class="cmt"><p>score upper bound</p></dd><dt>returns</dt><dd class="cmt"><p>the number of members removed</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/SortedSetCommands.html" name="scredis.commands.SortedSetCommands" id="scredis.commands.SortedSetCommands" class="extype">SortedSetCommands</a></dd><dt>Since</dt><dd><p>1.2.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if key contains a value that is not a sorted set</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>Since version 2.1.6, min and max can be exclusive, following the syntax of ZRANGEBYSCORE.</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.SortedSetCommands#zRevRange" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="zRevRange[R](key:String,start:Long,stop:Long)(implicitevidence$11:scredis.serialization.Reader[R]):scala.concurrent.Future[scredis.util.LinkedHashSet[R]]"></a><a id="zRevRange[R](String,Long,Long)(Reader[R]):Future[LinkedHashSet[R]]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#zRevRange[R](key:String,start:Long,stop:Long)(implicitevidence$11:scredis.serialization.Reader[R]):scala.concurrent.Future[scredis.util.LinkedHashSet[R]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">zRevRange</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="start">start: <a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a> = <span class="symbol">0</span></span>, <span name="stop">stop: <a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a> = <span class="symbol">-1</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Reader.html" name="scredis.serialization.Reader" id="scredis.serialization.Reader" class="extype">Reader</a>[<span name="scredis.commands.SortedSetCommands.zRevRange.R" class="extype">R</span>]</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="util/LinkedHashSet.html" name="scredis.util.LinkedHashSet" id="scredis.util.LinkedHashSet" class="extype">LinkedHashSet</a>[<span name="scredis.commands.SortedSetCommands.zRevRange.R" class="extype">R</span>]]</span></span><p class="shortcomment cmt">Returns a range of members in a sorted set, by index, with scores ordered from high to low.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a range of members in a sorted set, by index, with scores ordered from high to low.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>sorted set key</p></dd><dt class="param">start</dt><dd class="cmt"><p>start offset (inclusive)</p></dd><dt class="param">stop</dt><dd class="cmt"><p>stop offset (inclusive)</p></dd><dt>returns</dt><dd class="cmt"><p>the set of descendingly ordered elements in the specified range, or the empty set if
key does not exist</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/SortedSetCommands.html" name="scredis.commands.SortedSetCommands" id="scredis.commands.SortedSetCommands" class="extype">SortedSetCommands</a></dd><dt>Since</dt><dd><p>1.2.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if key contains a value that is not a sorted set</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>Apart from the reversed ordering, ZREVRANGE is similar to ZRANGE.</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.SortedSetCommands#zRevRangeByScore" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="zRevRangeByScore[R](key:String,max:scredis.ScoreLimit,min:scredis.ScoreLimit,limitOpt:Option[(Long,Int)])(implicitevidence$13:scredis.serialization.Reader[R]):scala.concurrent.Future[scredis.util.LinkedHashSet[R]]"></a><a id="zRevRangeByScore[R](String,ScoreLimit,ScoreLimit,Option[(Long,Int)])(Reader[R]):Future[LinkedHashSet[R]]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#zRevRangeByScore[R](key:String,max:scredis.ScoreLimit,min:scredis.ScoreLimit,limitOpt:Option[(Long,Int)])(implicitevidence$13:scredis.serialization.Reader[R]):scala.concurrent.Future[scredis.util.LinkedHashSet[R]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">zRevRangeByScore</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="max">max: <a href="package$$ScoreLimit.html" name="scredis.ScoreLimit" id="scredis.ScoreLimit" class="extype">ScoreLimit</a></span>, <span name="min">min: <a href="package$$ScoreLimit.html" name="scredis.ScoreLimit" id="scredis.ScoreLimit" class="extype">ScoreLimit</a></span>, <span name="limitOpt">limitOpt: <a href="https://www.scala-lang.org/api/2.13.1/scala/Option.html#scala.Option" name="scala.Option" id="scala.Option" class="extype">Option</a>[(<a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a>, <a href="https://www.scala-lang.org/api/2.13.1/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a>)] = <span class="symbol">None</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Reader.html" name="scredis.serialization.Reader" id="scredis.serialization.Reader" class="extype">Reader</a>[<span name="scredis.commands.SortedSetCommands.zRevRangeByScore.R" class="extype">R</span>]</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="util/LinkedHashSet.html" name="scredis.util.LinkedHashSet" id="scredis.util.LinkedHashSet" class="extype">LinkedHashSet</a>[<span name="scredis.commands.SortedSetCommands.zRevRangeByScore.R" class="extype">R</span>]]</span></span><p class="shortcomment cmt">Returns a range of members in a sorted set, by score, with scores ordered from high to low.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a range of members in a sorted set, by score, with scores ordered from high to low.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>sorted set key</p></dd><dt class="param">max</dt><dd class="cmt"><p>score upper bound</p></dd><dt class="param">min</dt><dd class="cmt"><p>score lower bound</p></dd><dt class="param">limitOpt</dt><dd class="cmt"><p>optional offset and count pair used to limit the number of matching elements</p></dd><dt>returns</dt><dd class="cmt"><p>the set of descendingly ordered elements in the specified score range, or the empty
set if key does not exist</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/SortedSetCommands.html" name="scredis.commands.SortedSetCommands" id="scredis.commands.SortedSetCommands" class="extype">SortedSetCommands</a></dd><dt>Since</dt><dd><p>2.2.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if key contains a value that is not a sorted set</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>Apart from the reversed ordering, ZREVRANGEBYSCORE is similar to ZRANGEBYSCORE. The
elements having the same score are returned in reverse lexicographical order.</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.SortedSetCommands#zRevRangeByScoreWithScores" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="zRevRangeByScoreWithScores[R](key:String,max:scredis.ScoreLimit,min:scredis.ScoreLimit,limitOpt:Option[(Long,Int)])(implicitevidence$14:scredis.serialization.Reader[R]):scala.concurrent.Future[scredis.util.LinkedHashSet[(R,scredis.Score)]]"></a><a id="zRevRangeByScoreWithScores[R](String,ScoreLimit,ScoreLimit,Option[(Long,Int)])(Reader[R]):Future[LinkedHashSet[(R,Score)]]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#zRevRangeByScoreWithScores[R](key:String,max:scredis.ScoreLimit,min:scredis.ScoreLimit,limitOpt:Option[(Long,Int)])(implicitevidence$14:scredis.serialization.Reader[R]):scala.concurrent.Future[scredis.util.LinkedHashSet[(R,scredis.Score)]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">zRevRangeByScoreWithScores</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="max">max: <a href="package$$ScoreLimit.html" name="scredis.ScoreLimit" id="scredis.ScoreLimit" class="extype">ScoreLimit</a></span>, <span name="min">min: <a href="package$$ScoreLimit.html" name="scredis.ScoreLimit" id="scredis.ScoreLimit" class="extype">ScoreLimit</a></span>, <span name="limitOpt">limitOpt: <a href="https://www.scala-lang.org/api/2.13.1/scala/Option.html#scala.Option" name="scala.Option" id="scala.Option" class="extype">Option</a>[(<a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a>, <a href="https://www.scala-lang.org/api/2.13.1/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a>)] = <span class="symbol">None</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Reader.html" name="scredis.serialization.Reader" id="scredis.serialization.Reader" class="extype">Reader</a>[<span name="scredis.commands.SortedSetCommands.zRevRangeByScoreWithScores.R" class="extype">R</span>]</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="util/LinkedHashSet.html" name="scredis.util.LinkedHashSet" id="scredis.util.LinkedHashSet" class="extype">LinkedHashSet</a>[(<span name="scredis.commands.SortedSetCommands.zRevRangeByScoreWithScores.R" class="extype">R</span>, <a href="package$$Score.html" name="scredis.Score" id="scredis.Score" class="extype">Score</a>)]]</span></span><p class="shortcomment cmt">Return a range of members with associated scores in a sorted set, by score, with scores
ordered from high to low.</p><div class="fullcomment"><div class="comment cmt"><p>Return a range of members with associated scores in a sorted set, by score, with scores
ordered from high to low.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>sorted set key</p></dd><dt class="param">max</dt><dd class="cmt"><p>score upper bound</p></dd><dt class="param">min</dt><dd class="cmt"><p>score lower bound</p></dd><dt class="param">limitOpt</dt><dd class="cmt"><p>optional offset and count pair used to limit the number of matching elements</p></dd><dt>returns</dt><dd class="cmt"><p>the set of descendingly ordered elements in the specified score range, or the empty
set if key does not exist</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/SortedSetCommands.html" name="scredis.commands.SortedSetCommands" id="scredis.commands.SortedSetCommands" class="extype">SortedSetCommands</a></dd><dt>Since</dt><dd><p>2.2.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if key contains a value that is not a sorted set</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>Apart from the reversed ordering, ZREVRANGEBYSCORE is similar to ZRANGEBYSCORE. The
elements having the same score are returned in reverse lexicographical order.</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.SortedSetCommands#zRevRangeWithScores" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="zRevRangeWithScores[R](key:String,start:Long,stop:Long)(implicitevidence$12:scredis.serialization.Reader[R]):scala.concurrent.Future[scredis.util.LinkedHashSet[(R,scredis.Score)]]"></a><a id="zRevRangeWithScores[R](String,Long,Long)(Reader[R]):Future[LinkedHashSet[(R,Score)]]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#zRevRangeWithScores[R](key:String,start:Long,stop:Long)(implicitevidence$12:scredis.serialization.Reader[R]):scala.concurrent.Future[scredis.util.LinkedHashSet[(R,scredis.Score)]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">zRevRangeWithScores</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="start">start: <a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a> = <span class="symbol">0</span></span>, <span name="stop">stop: <a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a> = <span class="symbol">-1</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Reader.html" name="scredis.serialization.Reader" id="scredis.serialization.Reader" class="extype">Reader</a>[<span name="scredis.commands.SortedSetCommands.zRevRangeWithScores.R" class="extype">R</span>]</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="util/LinkedHashSet.html" name="scredis.util.LinkedHashSet" id="scredis.util.LinkedHashSet" class="extype">LinkedHashSet</a>[(<span name="scredis.commands.SortedSetCommands.zRevRangeWithScores.R" class="extype">R</span>, <a href="package$$Score.html" name="scredis.Score" id="scredis.Score" class="extype">Score</a>)]]</span></span><p class="shortcomment cmt">Returns a range of members in a sorted set, by index, with scores ordered from high to low.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a range of members in a sorted set, by index, with scores ordered from high to low.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>sorted set key</p></dd><dt class="param">start</dt><dd class="cmt"><p>start offset (inclusive)</p></dd><dt class="param">stop</dt><dd class="cmt"><p>stop offset (inclusive)</p></dd><dt>returns</dt><dd class="cmt"><p>the set of descendingly ordered elements-score pairs in the specified range, or the
empty set if key does not exist</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/SortedSetCommands.html" name="scredis.commands.SortedSetCommands" id="scredis.commands.SortedSetCommands" class="extype">SortedSetCommands</a></dd><dt>Since</dt><dd><p>1.2.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if key contains a value that is not a sorted set</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>Apart from the reversed ordering, ZREVRANGE is similar to ZRANGE. The elements having
the same score are returned in reverse lexicographical order.</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.SortedSetCommands#zRevRank" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="zRevRank[W](key:String,member:W)(implicitevidence$15:scredis.serialization.Writer[W]):scala.concurrent.Future[Option[Long]]"></a><a id="zRevRank[W](String,W)(Writer[W]):Future[Option[Long]]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#zRevRank[W](key:String,member:W)(implicitevidence$15:scredis.serialization.Writer[W]):scala.concurrent.Future[Option[Long]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">zRevRank</span><span class="tparams">[<span name="W">W</span>]</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="member">member: <span name="scredis.commands.SortedSetCommands.zRevRank.W" class="extype">W</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Writer.html" name="scredis.serialization.Writer" id="scredis.serialization.Writer" class="extype">Writer</a>[<span name="scredis.commands.SortedSetCommands.zRevRank.W" class="extype">W</span>]</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Option.html#scala.Option" name="scala.Option" id="scala.Option" class="extype">Option</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a>]]</span></span><p class="shortcomment cmt">Determine the index of a member in a sorted set, with scores ordered from high to low.</p><div class="fullcomment"><div class="comment cmt"><p>Determine the index of a member in a sorted set, with scores ordered from high to low.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>sorted set key</p></dd><dt class="param">member</dt><dd class="cmt"><p>the value</p></dd><dt>returns</dt><dd class="cmt"><p>the rank or index of the member, or <code>None</code> if the member is not in the set or the key
does not exist</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/SortedSetCommands.html" name="scredis.commands.SortedSetCommands" id="scredis.commands.SortedSetCommands" class="extype">SortedSetCommands</a></dd><dt>Since</dt><dd><p>2.0.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if key contains a value that is not a sorted set</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.SortedSetCommands#zScan" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="zScan[R](key:String,cursor:Long,matchOpt:Option[String],countOpt:Option[Int])(implicitevidence$16:scredis.serialization.Reader[R]):scala.concurrent.Future[(Long,scredis.util.LinkedHashSet[(R,scredis.Score)])]"></a><a id="zScan[R](String,Long,Option[String],Option[Int])(Reader[R]):Future[(Long,LinkedHashSet[(R,Score)])]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#zScan[R](key:String,cursor:Long,matchOpt:Option[String],countOpt:Option[Int])(implicitevidence$16:scredis.serialization.Reader[R]):scala.concurrent.Future[(Long,scredis.util.LinkedHashSet[(R,scredis.Score)])]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">zScan</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="cursor">cursor: <a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a></span>, <span name="matchOpt">matchOpt: <a href="https://www.scala-lang.org/api/2.13.1/scala/Option.html#scala.Option" name="scala.Option" id="scala.Option" class="extype">Option</a>[<span name="scala.Predef.String" class="extype">String</span>] = <span class="symbol">None</span></span>, <span name="countOpt">countOpt: <a href="https://www.scala-lang.org/api/2.13.1/scala/Option.html#scala.Option" name="scala.Option" id="scala.Option" class="extype">Option</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a>] = <span class="symbol">None</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Reader.html" name="scredis.serialization.Reader" id="scredis.serialization.Reader" class="extype">Reader</a>[<span name="scredis.commands.SortedSetCommands.zScan.R" class="extype">R</span>]</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[(<a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a>, <a href="util/LinkedHashSet.html" name="scredis.util.LinkedHashSet" id="scredis.util.LinkedHashSet" class="extype">LinkedHashSet</a>[(<span name="scredis.commands.SortedSetCommands.zScan.R" class="extype">R</span>, <a href="package$$Score.html" name="scredis.Score" id="scredis.Score" class="extype">Score</a>)])]</span></span><p class="shortcomment cmt">Incrementally iterates the elements (value-score pairs) of a sorted set.</p><div class="fullcomment"><div class="comment cmt"><p>Incrementally iterates the elements (value-score pairs) of a sorted set.
</p></div><dl class="paramcmts block"><dt class="param">cursor</dt><dd class="cmt"><p>the offset</p></dd><dt class="param">matchOpt</dt><dd class="cmt"><p>when defined, the command only returns elements matching the pattern</p></dd><dt class="param">countOpt</dt><dd class="cmt"><p>when defined, provides a hint of how many elements should be returned</p></dd><dt>returns</dt><dd class="cmt"><p>a pair containing the next cursor as its first element and the sorted set of
elements (value-score pairs) as its second element</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/SortedSetCommands.html" name="scredis.commands.SortedSetCommands" id="scredis.commands.SortedSetCommands" class="extype">SortedSetCommands</a></dd><dt>Since</dt><dd><p>2.8.0</p></dd></dl></div></li><li class="indented0 " name="scredis.commands.SortedSetCommands#zScore" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="zScore[W](key:String,member:W)(implicitevidence$17:scredis.serialization.Writer[W]):scala.concurrent.Future[Option[scredis.Score]]"></a><a id="zScore[W](String,W)(Writer[W]):Future[Option[Score]]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#zScore[W](key:String,member:W)(implicitevidence$17:scredis.serialization.Writer[W]):scala.concurrent.Future[Option[scredis.Score]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">zScore</span><span class="tparams">[<span name="W">W</span>]</span><span class="params">(<span name="key">key: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="member">member: <span name="scredis.commands.SortedSetCommands.zScore.W" class="extype">W</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="serialization/Writer.html" name="scredis.serialization.Writer" id="scredis.serialization.Writer" class="extype">Writer</a>[<span name="scredis.commands.SortedSetCommands.zScore.W" class="extype">W</span>]</span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Option.html#scala.Option" name="scala.Option" id="scala.Option" class="extype">Option</a>[<a href="package$$Score.html" name="scredis.Score" id="scredis.Score" class="extype">Score</a>]]</span></span><p class="shortcomment cmt">Returns the score associated with the given member in a sorted set.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the score associated with the given member in a sorted set.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>sorted set key</p></dd><dt class="param">member</dt><dd class="cmt"><p>the value</p></dd><dt>returns</dt><dd class="cmt"><p>the score of member, or <code>None</code> if the latter is not in the sorted set or the key does
not exist</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/SortedSetCommands.html" name="scredis.commands.SortedSetCommands" id="scredis.commands.SortedSetCommands" class="extype">SortedSetCommands</a></dd><dt>Since</dt><dd><p>1.2.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if key contains a value that is not a sorted set</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.SortedSetCommands#zUnionStore" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="zUnionStore(destKey:String,keys:Seq[String],aggregate:scredis.Aggregate):scala.concurrent.Future[Long]"></a><a id="zUnionStore(String,Seq[String],Aggregate):Future[Long]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#zUnionStore(destKey:String,keys:Seq[String],aggregate:scredis.Aggregate):scala.concurrent.Future[Long]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">zUnionStore</span><span class="params">(<span name="destKey">destKey: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="keys">keys: <span name="scala.Seq" class="extype">Seq</span>[<span name="scala.Predef.String" class="extype">String</span>]</span>, <span name="aggregate">aggregate: <a href="package$$Aggregate.html" name="scredis.Aggregate" id="scredis.Aggregate" class="extype">Aggregate</a> = <span class="symbol"><span class="name"><a href="index.html">scredis.Aggregate.Sum</a></span></span></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a>]</span></span><p class="shortcomment cmt">Computes the union of multiple sorted sets and stores the resulting sorted set in a new key.</p><div class="fullcomment"><div class="comment cmt"><p>Computes the union of multiple sorted sets and stores the resulting sorted set in a new key.
</p></div><dl class="paramcmts block"><dt class="param">destKey</dt><dd class="cmt"><p>sorted set key</p></dd><dt class="param">keys</dt><dd class="cmt"><p>keys of sorted sets</p></dd><dt class="param">aggregate</dt><dd class="cmt"><p>aggregation function (default is Sum)</p></dd><dt>returns</dt><dd class="cmt"><p>the number of elements in the resulting sorted set stored at destKey</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/SortedSetCommands.html" name="scredis.commands.SortedSetCommands" id="scredis.commands.SortedSetCommands" class="extype">SortedSetCommands</a></dd><dt>Since</dt><dd><p>2.0.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if key contains a value that is not a sorted set</p></span></dd></dl></div></li><li class="indented0 " name="scredis.commands.SortedSetCommands#zUnionStoreWeighted" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="zUnionStoreWeighted(destKey:String,keysWeightPairs:Map[String,Double],aggregate:scredis.Aggregate):scala.concurrent.Future[Long]"></a><a id="zUnionStoreWeighted(String,Map[String,Double],Aggregate):Future[Long]"></a> <span class="permalink"><a href="../scredis/RedisCluster.html#zUnionStoreWeighted(destKey:String,keysWeightPairs:Map[String,Double],aggregate:scredis.Aggregate):scala.concurrent.Future[Long]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">zUnionStoreWeighted</span><span class="params">(<span name="destKey">destKey: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="keysWeightPairs">keysWeightPairs: <span name="scala.Predef.Map" class="extype">Map</span>[<span name="scala.Predef.String" class="extype">String</span>, <a href="https://www.scala-lang.org/api/2.13.1/scala/Double.html#scala.Double" name="scala.Double" id="scala.Double" class="extype">Double</a>]</span>, <span name="aggregate">aggregate: <a href="package$$Aggregate.html" name="scredis.Aggregate" id="scredis.Aggregate" class="extype">Aggregate</a> = <span class="symbol"><span class="name"><a href="index.html">scredis.Aggregate.Sum</a></span></span></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a>]</span></span><p class="shortcomment cmt">Computes the union of multiple sorted sets and stores the resulting sorted set in a new key.</p><div class="fullcomment"><div class="comment cmt"><p>Computes the union of multiple sorted sets and stores the resulting sorted set in a new key.
</p></div><dl class="paramcmts block"><dt class="param">destKey</dt><dd class="cmt"><p>sorted set key</p></dd><dt class="param">keysWeightPairs</dt><dd class="cmt"><p>key to weight pairs</p></dd><dt class="param">aggregate</dt><dd class="cmt"><p>aggregation function (default is Sum)</p></dd><dt>returns</dt><dd class="cmt"><p>the number of elements in the resulting sorted set stored at destKey</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="commands/SortedSetCommands.html" name="scredis.commands.SortedSetCommands" id="scredis.commands.SortedSetCommands" class="extype">SortedSetCommands</a></dd><dt>Since</dt><dd><p>2.0.0</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt"><p><span name="[[scredis.exceptions.RedisErrorResponseException]]" class="extype"><code>[[scredis.exceptions.RedisErrorResponseException]]</code></span> if key contains a value that is not a sorted set</p></span></dd></dl></div></li></ol></div></div><div id="inheritedMembers"><div name="scredis.commands.StringCommands" class="parent"><h3>Inherited from <a href="commands/StringCommands.html" name="scredis.commands.StringCommands" id="scredis.commands.StringCommands" class="extype">StringCommands</a></h3></div><div name="scredis.commands.SortedSetCommands" class="parent"><h3>Inherited from <a href="commands/SortedSetCommands.html" name="scredis.commands.SortedSetCommands" id="scredis.commands.SortedSetCommands" class="extype">SortedSetCommands</a></h3></div><div name="scredis.commands.SetCommands" class="parent"><h3>Inherited from <a href="commands/SetCommands.html" name="scredis.commands.SetCommands" id="scredis.commands.SetCommands" class="extype">SetCommands</a></h3></div><div name="scredis.commands.ScriptingCommands" class="parent"><h3>Inherited from <a href="commands/ScriptingCommands.html" name="scredis.commands.ScriptingCommands" id="scredis.commands.ScriptingCommands" class="extype">ScriptingCommands</a></h3></div><div name="scredis.commands.PubSubCommands" class="parent"><h3>Inherited from <a href="commands/PubSubCommands.html" name="scredis.commands.PubSubCommands" id="scredis.commands.PubSubCommands" class="extype">PubSubCommands</a></h3></div><div name="scredis.commands.ListCommands" class="parent"><h3>Inherited from <a href="commands/ListCommands.html" name="scredis.commands.ListCommands" id="scredis.commands.ListCommands" class="extype">ListCommands</a></h3></div><div name="scredis.commands.KeyCommands" class="parent"><h3>Inherited from <a href="commands/KeyCommands.html" name="scredis.commands.KeyCommands" id="scredis.commands.KeyCommands" class="extype">KeyCommands</a></h3></div><div name="scredis.commands.HyperLogLogCommands" class="parent"><h3>Inherited from <a href="commands/HyperLogLogCommands.html" name="scredis.commands.HyperLogLogCommands" id="scredis.commands.HyperLogLogCommands" class="extype">HyperLogLogCommands</a></h3></div><div name="scredis.commands.HashCommands" class="parent"><h3>Inherited from <a href="commands/HashCommands.html" name="scredis.commands.HashCommands" id="scredis.commands.HashCommands" class="extype">HashCommands</a></h3></div><div name="scredis.commands.ClusterCommands" class="parent"><h3>Inherited from <a href="commands/ClusterCommands.html" name="scredis.commands.ClusterCommands" id="scredis.commands.ClusterCommands" class="extype">ClusterCommands</a></h3></div><div name="scredis.io.Connection" class="parent"><h3>Inherited from <a href="io/Connection.html" name="scredis.io.Connection" id="scredis.io.Connection" class="extype">Connection</a></h3></div><div name="scredis.io.ClusterConnection" class="parent"><h3>Inherited from <a href="io/ClusterConnection.html" name="scredis.io.ClusterConnection" id="scredis.io.ClusterConnection" class="extype">ClusterConnection</a></h3></div><div name="com.typesafe.scalalogging.LazyLogging" class="parent"><h3>Inherited from <span name="com.typesafe.scalalogging.LazyLogging" class="extype">LazyLogging</span></h3></div><div name="scredis.io.NonBlockingConnection" class="parent"><h3>Inherited from <a href="io/NonBlockingConnection.html" name="scredis.io.NonBlockingConnection" id="scredis.io.NonBlockingConnection" class="extype">NonBlockingConnection</a></h3></div><div name="scala.AnyRef" class="parent"><h3>Inherited from <a href="https://www.scala-lang.org/api/2.13.1/scala/AnyRef.html#scala.AnyRef" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a></h3></div><div name="scala.Any" class="parent"><h3>Inherited from <a href="https://www.scala-lang.org/api/2.13.1/scala/Any.html#scala.Any" name="scala.Any" id="scala.Any" class="extype">Any</a></h3></div></div><div id="groupedMembers"><div name="Ungrouped" class="group"><h3>Ungrouped</h3></div></div></div><div id="tooltip"></div><div id="footer"></div></body></div></div></div></body></html>
